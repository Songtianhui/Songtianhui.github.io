<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021美赛总结</title>
    <url>/2021/02/12/2021-mathmatical-modeling/</url>
    <content><![CDATA[<h1 id="契机"><a href="#契机" class="headerlink" title="契机"></a>契机</h1><p>原来是在表白墙上看到的招募信息，没有抱希望地去问了一下没想到真的成功了，然后在比赛前一天混进了有两个大佬的小队orz</p>
<a id="more"></a>
<p>其实在看到了招募信息后纠结了挺长一段时间的，比较担心别人不要我或者工作的时候我啥都不会给别人拖后腿挺丢人的。。。不过最后下定决心(腆着脸)去试一试，感觉就这么一个机会而且美赛算是认可度比较高的一项竞赛，大学就这么多年有机会还是要把握，最后果然能成而且表现还不算太差吧ww<br>感觉大学真的学会抓住机会很重要，有时候确实得需要去厚着脸皮，突破自己的舒适圈去争取一些事情，做一些“万一成了就是赚了，没成也不咋亏”的事</p>
<h1 id="建模中"><a href="#建模中" class="headerlink" title="建模中"></a>建模中</h1><p>真的开始工作了才知道自己真的差太多了，建模知识几乎一窍不通，python在两天前真的才刚在学<code>print(&quot;Hello, world!&quot;)</code>啊qwq<br>总结一些第一次参加建模比赛所学到的一点东西吧:</p>
<ul>
<li>python和matlab才是主力，cpp真的毫无卵用orz。所以目前至少一定要把python给学熟练了</li>
<li>python几个模块非常重要，python基础学好后一定专门找时间把它弄清楚了(numpy数据，pyplot/seaborn画图，sklearn, wordcloud…). 关键对于各种数据类型(dataframe等)和各种函数的接口的理解</li>
<li>数学建模基本上按照建模、代码、写作三个part来划分工作，可实际上也没有划分那么清楚，而我在这三个方面基本上没有任何工作力(latex排版稍微能帮上一点)，而且可能用到大量的类似机器学习、深度学习的知识，所以要学。。。</li>
<li>临场学习的能力真的也很重要，此次在工作中的任务基本都是靠从零开始快速学会，像python对excel/csv的数据处理以及可视化，tf-idf和词云等，也证实快速掌握一项能力是可行的(在积极主动地去学习的前提下), 大佬队员所说数学建模真的能大大提升你的skill set</li>
<li>小组的合作交流真的太重要的了www，这次的两个队员真的太nice了，既大佬又不嫌弃我还耐心地给我安排以及讲解一些工作，对于一些具体的工作还会拿出一些例子给我看，真的很感恩</li>
<li>python真的是世界上最好的语言！对py的理解和代码能力突飞猛进</li>
</ul>
<h1 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h1><p>这一趴真的太惊险刺激了，甚至到现在也没能放下心来orz<br><strong>总之一点不要把所有工作压倒ddl最后一刻，预留足够多的时间来做overview求求了！</strong> 本来就10:00 am的ddl结果9:55才算全部整理好开始下载提交结果遇到了队长网卡，pdf太大以及投递失败的问题，血压拉满到10:15才提交成功<br>关于pdf至今未能知道为啥它会这么大(47M)，估计应该是图片太多了吧。。。实在没办法可以找网站压缩，比如<a href="https://www.ilovepdf.com/zh-cn/compress_pdf">这个</a>还挺好用<br>然后它给我把47M压到了500k我也不知道怎么做到的。。。</p>
<h1 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h1><p>差得很远继续努力，技能树需要点亮很多很多，python和机器学习必须赶紧熟练掌握<br>然后在国赛的时候多学一些建模的知识，争取在下次比赛能够形成较为系统的意识<br><img data-src="mm.JPG" alt="conclusion" title="conclusion"></p>
]]></content>
      <tags>
        <tag>mathmatical-modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>2021寒假计划</title>
    <url>/2021/01/28/Flags-for-winter-holiday/</url>
    <content><![CDATA[<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><pre><code>先把这个blog基础设施搭建好，配置到一个最顺手好看的亚子。
</code></pre><h1 id="装系统"><a href="#装系统" class="headerlink" title="装系统"></a>装系统</h1><pre><code>用了一个学期虚拟机真的太累了，真是又慢又卡orz
准备装一个Ununtu比Debian用起来优雅多了，不过电脑磁盘不够了得买个移动硬盘。。。
</code></pre><a id="more"></a>
<h1 id="学习篇"><a href="#学习篇" class="headerlink" title="学习篇"></a>学习篇</h1><p>有想学很多东西但可能只能停留在想的阶段。。。</p>
<h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><pre><code>学个python吧，python是世界上最好的语言!
</code></pre><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰python教程</a></p>
<h2 id="ML"><a href="#ML" class="headerlink" title="ML"></a>ML</h2><pre><code>看看吴恩达？机器学习好像很多地方都有用。
</code></pre><p><a href="https://www.bilibili.com/video/BV164411b7dx?from=search&amp;seid=11011536408088050441">吴恩达机器学习</a></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code>LeetCode做做题吧，算法比别人差太多了orz
</code></pre><h2 id="Mathematical-modeling"><a href="#Mathematical-modeling" class="headerlink" title="Mathematical modeling"></a>Mathematical modeling</h2><pre><code>那可能还要顺手学一下mathlab?
才知道有美赛这个玩意儿。。。现在着手可能晚了，也组不到人也没人要我这个啥都不会的菜鸡w
</code></pre><h2 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h2><pre><code>既然可能学不到什么新技能，不如预习预习下学期的os...这学期ics已经炸掉了，保住成绩也不错。
</code></pre><h2 id="Teaching"><a href="#Teaching" class="headerlink" title="Teaching"></a>Teaching</h2><pre><code>估计师说那还是要找我去上课的，既然没有动力学习把时间转换成money也行。
</code></pre><h2 id="Hobbies"><a href="#Hobbies" class="headerlink" title="Hobbies"></a>Hobbies</h2><pre><code>搞点课外兴趣，procreate画点画。可能再学点剪辑(?)
</code></pre><h1 id="谈恋爱"><a href="#谈恋爱" class="headerlink" title="谈恋爱"></a>谈恋爱</h1><p><strong>好！</strong><br><strong>我爱npy!</strong></p>
]]></content>
      <tags>
        <tag>flags</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown test</title>
    <url>/2021/01/26/Markdown-test/</url>
    <content><![CDATA[<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><a id="more"></a>
<hr>
<p><strong>加粗</strong><br><em>斜体</em><br><strong><em>斜体加粗</em></strong><br><del>删除线</del></p>
<hr>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p><img data-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F201709%2F13%2F20170913224334_BNTZG.thumb.400_0.jpeg&amp;refer=http%3A%2F%2Fc-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1615734130&amp;t=6ff751ad338c71d43fdc49f9a178a53c" alt="这是一张图片" title="This is a picture!"><br><a href="https://github.com/songtianhui/songtianhui.github.io" title="github repository">这是一个链接</a></p>
<p><img data-src="avatar.gif" alt="这也是一张图片3" title="This is also a picture!"></p>
<hr>
<ul>
<li>列表内容</li>
<li>列表内容<ul>
<li>列表内容</li>
</ul>
</li>
</ul>
<ol>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">这是</th>
<th style="text-align:right">一个</th>
<th style="text-align:center">表格</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">左对齐</td>
<td style="text-align:right">右对齐</td>
<td style="text-align:center">居中</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>Here is <code>code</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<script type="math/tex; mode=display">S_{n} = \sum\limits_{i=1}^{n} \dfrac{i(i-1)}{2}</script><p>行内公式$\kappa_{s} = \overline{\alpha} + \beta \times \pi, x = \dfrac{-b \pm \sqrt{b^{2} - 4ac}}{2a}$<br><del>好像没成功…Σ( ° △ °|||))︴</del><br><strong>成功了！</strong></p>
<hr>
<h1 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h1><p><span class="github-emoji" alias="smile" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">&#x1f604;</span></p>
<p><span class="github-emoji" alias="dog" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8">&#x1f436;</span></p>
<p><span class="github-emoji" alias="joy" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">&#x1f602;</span></p>
]]></content>
      <tags>
        <tag>This is tag</tag>
      </tags>
  </entry>
  <entry>
    <title>和芝麻的旅行日记——武汉篇</title>
    <url>/2021/04/11/Wuhan/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="32c54ca0169166e577062539e73ea2d5be0bbed87f10e958cebb7cb65a15ef15">8e8262f4c8b4badbe165aed5587f464d818e49d5ced7dee8633c4437270a54e2a3a48c49ce90a3b3da7d595176ee9742d8c1d58c91a87f8e519aeb6ef5f9722a99c9099dab34c11f9b79d5d59428135159d4ef979dbad40ef950fb46aa278f2f9b07d91ec32be45f80cba3a9fb69ab016afbf235884cb0acd2faaac2c9ae64908004049d103cf0f1eb5ecdc6ab95687d4f031adad7cdf6d47448e47f11eede9a0226ab1115b8e9195bea25593826fd27817e064b3e5724790a758738329fdef485f0db55b11136e0cb131e14276fb9e86e3e1e07d5cf5fbef1700d5899a1e57579b3fa026e5b33cd2b7b63cb63d02bb906a245aed342c4432fd966dd2223667b44dc9100437913af931a228738c9715a7f852068b4a5c270438a55099af69851f1dea0d50e50be7174967af58bd13401b8bc2e266f7dbe78ad5144ddaa66b80b5dfaeaab38c2709ddc6a23faa28c816c143ff0b78cd31b8bdab34fdf7a5aae9a8fe2cbd105a8ecec287b9a238b42a72505c5a2877eb6060636a49942bf1695d319fd926e7d64b57c3b4baa464e9c922477df7a21d9b56652d5f07ff2653b95ec94716f11e49e60f0c5029164a14f11eee1a12fae139e13f058f6166f5a8e72aabd422a03c9cc308eef88c3b4270f3b77fae570c9174ed3329e9155761a9b54575cd05079b9fc4c8e6c4465f1f7ef0e1c9c2212eefea9682d4bbc9a76341d16e8b87e608edb375f7117ca897005722e6be5cc94aab733838b894a2e4e50e4a1f3cba08f134c19ba1be8882fd497c956f81800aa5e06d3df598b481d2799727f0d6428d23b1771ccfcfb8cd0ec4521fe55627cec513f04845c7e7731fd2cd945cdb1894ebb59713dedc4745efcf6fb8d5a526bfe4ae6bd259c9357f3561450e45a046f43573b97fe6a1c7ab45c1580fc3fbdc4181b2d4bd2f8fb32fe89586ba3f1b8afea9136d0fed85b47e8d8579cb3eaa2f6bd7948d80091739451b941944b8ac5240a17523770797062a4f21776b0986e08dd37436f30e54dce545ac9c5bf86d8602356b0b9aec5ef978ea804f806accafbd1514f38e26b38e395e0681b896e5a26e8be4fb98c5e846c0f28a5e3a3c14bae0fa40d63948fbfc8a5e214e7844ff8164e8081d4839ef6cd127c8c6149258f7447cd1b960712ea5291b10329131117d8452161323c34cd3be9ba77b881f18a0231bbd51c24236a4785ba1cd7ad80cbc7b61d8cd7df1c9f197b981e9c631c2acf619e1a6de7c107ce1666ea304b3838afbb58ef91619d5599217c4fb380186d9ddb1db2d561f34743291579d38c8b99b39939933c0b6f15c93da6dfbb7e28198430cf5dff2703ac4199096c7407d1edee137db59d8715936b6a166794b415cfb6326faadf59e3e63b4df05fab1b7062342c442ca8effb97d9d5eef80744f79ab5d9d39f510161436debde700299ff075e0e99b8ff8561a8bd60aaceff4e2fc3cbac449afe72c040dc3b44dadd45948a0283ad5fbe66aea66a9a607753c57ddff4bdab17ef667126d873b88f97a047592796f3fb4d7ec397ea7e25d54b015be0141a7ee15eedb8fcf7b7cada20f9c00e5fe97eee6be24f0c9ddad2e11b92bded1b2bb3860a2055eda05f2cc7784689af84631a8a04cd74541ec0ec36d96ee7a021db850d1ae0841b740119c8d410497d84d234f824c0d5dc844c452e44b46c4e73d43cf643dcf33e17cd12b1f02c28bb16c050b9d1422a17f31f09472e372ff5f7de1bb20380931e65713643c1948c62f1a8f117ef80b64c341165fb4713211d6d44f59748f62fbff491641cbea0fa8df5fe189e3351950e5ddf054b83360b4f6d97b3539864e21f36eb1022bf44ff080f65639e93e990d70b4ca54e0b587baea781e0eae205c5ffea139b5757a8fba7826763d6520eedb15e17a58d8a83678c6f119acd02b4718fadd69786343f1c8088dfdc4b3d73e86f3922116d2eb35d195f653b2c7fecca6300f290983ee2782720453a79972c784116e9296bbf955936ddfd99bbd46b5f443b0582640b61836a02d1474fcf04d21cc6bffd174d476c2b580a5ab0397ac6036275cdad72f3adae9c1684c0fd44360316a8adc519de0c2805be1fc3cea0e950d73dd8ebaf1fd04740d1637879ba9829f7bfd767edc38743d1a1ffa4e8000ec6bbd8288a411c13b37ccee53879740fc3e21b283f511fb9a9bc1fe33007e3ee2f75bbf0a998b2df5fe03583a8cf89cd9d9ebd8c7d32b034191d588d741cfa24ace53fc577c8ae6fa46dd116de845f9727a621e0e0bebf83afe1d57d65929a9ad89d67ff87daa7b83a596316209ffd4d9c2c889e6a98695030345a50f560e6173ac09a3d4a5b4d51881d6cca7de6cf1dccc0bde5721b80d70322c2372b8cfd709f77c70728d7b74edf47e1aa655f96f27ab77d0a5db40f0a3b86243bb13dbf62b5d528451af52ce0307bd94ae5bdf8e14ce82f3f7e0427ea61ca40be87b4e02e1756008059afbd863643c6d4460f9262984585e3e1541e64df439bb004e45b10be75448b4f3153b703196add89a0cfd077da532d3b185ae48ec54cc78da8c2ac4d5f3e070f91ce16ad08dbceba061bf508c9f6a3487f3af12b221b5ebf8258937cd7f8ff4a7d689f8cfa1894397c0eda097e3f710a8dbc4fb2f083c3026087a98117fdb2c92cf593d35f848fb53e0523d11f2c301efa3dfc396e54fcf7277c860b69a2e4c4ee554c2d6d3ea66d301f2fbdd9b267528cc9578092a19d598e3255e7c0f41b9bf6f8d18640043e240e9fa4cb64d490a0c1d5f76e3c172ef469c8047fd104d22f92115be5e2657915a1ce737e4f1ad08a59b0b97e4120f69e5b6748a3869cf96cc629ee004752ae126d11b495e2ed746dc54755c53cb593d9ed0ac6c5efc3de622180e2b93975428199da755f06fa336d8b23bb8d9afb1d4c83498802db2a24641e83fcd32f827b4dea8ceffa83b014dfa730d039c0610b5f4f7613be0a20d82f451a8efef063a92bcadb9eb6cf70775e69b02a799566590d2ad56678c75101d53d707a7f80e54722b631bbe3a858f078f7f869dc46cde6504354d1a9b4f9e01f7cd66c2409caa9e94c866dcc8d1a4cb262dab7e2489ff424683315f97dffcee1f33c26197de2a70c6fb92e6f565d69800c5df05719eacbf52622f46b0d12aa7b5a76f3d496c422cc1bea31d15d237a01b2e2e4812bc4654e001b55f14e4cea02e545dec31514cd50b1dc5722d0a31ed11f59d0276d47fc9d827d6b9284977c93a9a6c8bbccfeb9f5d3a715548f2b216409fde269b928072e81b4d89db01471c8d39fcb6107654ce2236a3657b81379a340e5e492a4d52191b60a4a2958688fdb7e49b79cb4a36b7e77ec12aa8d183adca608b8c74205b55ac3638b10412dabd57bf1d355a25410d113aa7c3091dbc686a01d5f652644facd7dd0191762a435be4f3f558eac50d2945690bf2ccba3097d94763c2c10aaa14fec5acd0b422249e8ef4c3444afa08bda1f7a452f71e3b241d3f5d7c8295e18c6f6208abf280bf72532cf203026eb66babe1c3d27f5c445768212f1a57a98c40e990a4db303558c25c9a5df08a53b12bff9bc0a58d66ff039f463d308c524b6c15c1fa602ad62b8d4ce47c526e7f6ee32a607c230e1cd181d0e0cb294f74d1617d5706684e15063717b0e87c5877ea04145f0d000b4c065d8390564aa82bc08f838c29026cf33f007a8ce2a5755353ec45b1bee8c5b70d2e0ad654cd64c84fd44b1a22c06f71c513f170f8f0ba99cb611b2daadce4dc865c194ae6052a532ad476002db9957211170cdd69848185002a76a1fba3c2e0caf0100939ccbf1871d2be2f89a52414c06f941838afae9bdae34a3e56901849fab7096ea2dfd6038d5167db31ae6e076c046d16d50d5d844db206f2e7bdab9dae81c681f8dc837036ce374f211a3676a5a447eb54abcfd844e73588339d83d5826508998ea58241ff686edbc0caad6e07e5bc4de7ba23f6c1da6e21fa8102f34cb2137b15267984c9cc7fca795264163717e5b1f5460dfedb8cc76ef4de3b6c81908496375b19fb7282fd0e612328cd50e1d58b0df3c99b764aa8129d52ed8c647c80367390235bdc79c68844d2c8ef2ff949689ad86afe6671a8565f2d6fba223005818f6ece33f32a6ab3b5a36c47aced8009019d45c0cec0a877ca267c86bf819b19f4d27355da4613ee54537c874930bdfda5646be60c95d298044a8363d79fc9d0913fbcef3d309c5a63150dee5c15b12cfa9dc57b7895b5d17b4ebdbac28327f86d84baad2ca02e3422b36e3b4862182772591ec79470ba5906558832a10a2b6a2d109672a52562e816770964e0928af267e1e9c1fefad398b89a7bf82b02365b2304aeb90a8124519c16ce867c57a78cb602272796196d46b4da9c275e0075c303d2fbf63a268096ef7ec8e287617248c21c07f7df4c6b5e49e0ecd8e50c76c986ffe90a57b5a1da346e94ce69f607fc15eda73871ba3556724d4e073bc8ff17e4a9175b6e7d04bcedb169654599a1bc74fa69dcf2933a4c858d23e9ca434e3d0e1d61398b941c5e84ab5fee4bcc06c98cf0389170209524a613370efc0d317a04295ebac72c5a9f8c68bd455f61eefa97b9d4a0fc402923d61f84343491847d4c98b35f4b1a6833fd50255889695ea8aa7a0cff437d8b7534bc569d44e9052c027214778937d6c349dc9190474e12e346ef50dea97e642d1f8e2ece921c7b098bc45b222f3738a37bf4646bfcf3834c32cdc3dc3d6809542e58c8462bc7563a88debe22123c89bc3512bb59d22d191db5e22968e8c4c8984571636061ebb57d89821980c57789f0b4cb7bcc302d8adc3889dabbd53e9487c7073b770bd9298b6c2ecd12e5092f93eddd49713ebf2ba52b66f4f2e39fbf85535e7f3afdf3a301e3253bb193a4ed54b0ebb79d66680b1e57c0e8624e511642e2333d485ebb05e004d688bf0f31103829890c99af368bc6d9aca6f7628a11c2abf16b4b26ff61aab843b1585a19df3648f461ac8164ccd070e38680ab34518830e8697002955c22037509019b55972b350ee4da21a06688221f01b82c92dab2c010a9ef5d1ef671c81a0ecd7136a43ea0af123c841f3461f0c0f6773787aa73457f8e64331a5fa6b8c48e33b8ab5de308f0e670ffbd03466501f5a62f8587d6a72280e717ff5dea074cb16142b30dec0b76d69ec46e78aa2911fbcb85b7270f57280704e5fb13eee41558835d60e940e7d14ea649cc3d3f30d195a97d4e858758bbca3bce0d8bac0474719cd13762d8206eab4ed501ee6f1609a049c5fabc1ab150a0cae4474caded0dcd47044f64c85fda7b327887dc8e2684017e268afefb90ee3df5a0f7f5a1d0ace0ee979485a0c1c5e4a2a9cd29cff31657c25ea07a3c70090eb7e21bbca0d254035f4451fbb4cce72d87144bdc6081274b6a0ed738fc06523862b001692af3460420cca70c5c516ff75b708d3534f507853013158031c4627ecce8041dc852266b6db547cae1606888fb26c1b2f3e4600feb0cce8c420004107af163ecc216c2a177e624d4cd7a7382893c62f1e80377dab03e885f0644d4f6f959edd4ba21956b11ffe7f21a688d5c15192b898750ded54934ea32319b7cbef99d1d576e925a47deaa0847a4be3c06534eabb85d5035dba3bf1277cc45b0d972ff7d4dc68def0f7a20c87ff7118cc017670cfd5d42342c46a11f5089b5867ac3ed179ad3c1901b455da59d902403f824929e4140c33ebdef8e099692c617bafc29ab89311f88880f9d237f7340ebafa6081650b94984d0fe57d979de48697d2772d1a1a128750a7d5a45ff6df1108906fb3d88e877be6d346db4227c65d4824226dd1f3729f673309d9f2ff9b01c5564fd6253128fc7ef52aa35acd61e87e7d0cfdabd539fff51d2194279e269b8e3acbd53c0b26dd3a3e7c8faf9f0017016fe67902b124f20fb6bd9731614754ac5c3dd036b13554dda915d8c9ca9595a0e59ff2cd18e3dba1b48686314404e8a49a8bc4522c3f332a667b6eba3dc23af856c810bacd0291d1c2296670f105d812cae0296b15e44a99de8e13afc433b5b2e530501d67eb29a97e5f34ca472b98c235edb1740229e96f3256c6d3bc7f6990a592d7391276192fb50d351c0e282abe2a1ef66cdb6c6a755f2a70756aceaaea377f31c4c7eefdc74474cfe1a6aed60219c86d5d1bf13d5e577eaf2bc9a9e0771c1f3dab75d3a422c7438acddc810821a15bc811dbcc2847456469933e7593c403b1df4721044bc9993b8f8b5788157795e3c617b329cc9956a34575f40c58ff1f3d5b4a3adb2d0da6a434cc6a0728bdfc75a1fc4b0b44e5e6ebb9fd97fad09dcd5d89cd389168482233f751bcf4a4fe1f3aa572fb8f89d6f056471ec46e34604ea13305812fbb23b54141e89b6af121e0b1488af97e9f4b6b95a08e884636fad1e7f00bab6cf0a20ca51c586441164f700d29358ce8fc8d459c956f3c793b2ea2bb80b15b3280e729e747d7e743db9cbee4be76cf7be9e4efd4a961b5c6b964d0628600bfd8c58674d83da99cbc6b6aeb8f6ad68ff3ad476d13753e4a11aa34f692dce807ab0716f0848e934887976bf16924409be1f107ac412ae5a096a76ed3babd6d87d2e6d1bb5d980bcdc6dc1541c58f828eda55332ab642fc0b5e168ee6a5203fd6169cbbd6c9e1b3388e8f1120a7bebd12b0d25a8a580e4c5e6903e9acd117d019ef5d741983b2fcfceca92982d8732979a1b23cfe6bbeeeb4de322cf417221127e6deaaf2a3a594e36d9bc60bae3642028d6f69ed2f8e6ebe8aa3d47ebc6d2168615c809d46dc64d3af21ee7433d53ab47207dbcb60f3c28e9027f6f7ed6b989a7acf4992768654dfa06d24965a4bc345242e109d09151d0bdb2bacc3e6716b70291b2aa1e3453475708cd051e114ee5532cb58ab00bb11ab9869e212ecf6e58fa3fc7bfd5555a660d55ac8906b33a5ddc887c43f29213e8d0ed3edb0c2faa33a208e6b949ca1cd088b6dabcbd69fe30aae8cb531438b00861e5bc2756694b4c72beac2c943dfd2fc460d77dad8ad3eca9de53839d412f28b44c864a1371711826eb729eb67d7e10b3610735074ee72529e05777b3ecfc4f9fc436aa00f886241cae75151219dd39e8e15ddf8c02f4d3594d967c70c70be2dfa3a5734842443f5968d8b68060e92c8fee7e0b27425afd6768e44321a67ab747327fcec965fa9fe97a87cf8d5d46f8280374a61d977a7e9e74091b1af09d2cfb4f3c883e14365b2604fb5aedb834734f9f4fddb6b84c6827dd6f630a4e607f6e2b94626dc012746f4c62fcf96920513245ad7d69a239e77b8ded986b1b18c9dd785e447872f2895336135ea5a2c278e28eb9376010b139c6131285488a8e4f7b8ab2317474dff3759a594cae960f90b003aafe8cbe49332fefe86ed4c147e4fe671faf6bb197031f1fccbca15a2d9f9f7aff4353e28786de22929e8b1721abd33edaa5e487113f4519b86c55bf7cd4418689b16164bd4e979a46559be101da184b2c20b56be43e74598cef78b7b291edbd9fdaffe5be1a59f08e207605f485e81dd5be5d73ed6bf6c3d028895ec7e68a42200b63fda5cf86e8323136089bd8581bb7737c00c67e911bdfc34ce8ef420f5889219183f1e2c3660860eeb4935d6c41b634cc7ce19f777f5cd3901ed5a3587c897a9ebe649f92a93b715dea95fea1891f2866b8e50fca757d945fe101c407709fcfffac906bbacbcedc837e82e55e2556c0e8426dd7bcd2a19df4f40f3f12edab22dd5286fab57b9b89a4e6de88872a762f8317340d4b93f367f9a3d94fb5dd424861b7f886fc7d292faeded19635393d1b34671c361ee041e9120b02ba893228cc464567d3fa7b6c706141d909064e7c5e85f186a2deb838797829904a218f041238dca045083dafc9f3f5012b4c4596296f32ca853ac423f0a06180aa4899a1f5b9c385f2c6593b56334d23e8efc505fbc274e767324f0d4042ccbab026d839ba1d42052a6a697215c581c0cc8752ac09f3b7e6cd0b3f9db65c176dbdffa0c1edfb6ad88f231b4b606cd5a8fcaf9bfabc46b662d67e7dd1ad8dd177236fbac71777b3243a836f9b5ac17215e884a02169c2805685aee2c5511170068af9ec2cc891acee670805e0aebbaca6d2b83f60dccab0356582d56f9470260daaabf6c64201837e6fada402d424161f09546d562f7751e4f6b9f057e4517dd65508d7c1b0eb4047ce6be6c6bd7fcfa06c95e376bde744a16858ebfc20c12d3dd827ffb6ded6bfd3207677fa498d4dd74af6b1e830bbb77880a0e10ae7f33827d76500cf6dd0badf1f021a0b9630be42d9509cd1d689c1b575c5e91c5895ee50cf153f1b1f07a85238dfe707592bd635a5077ed5eb28d9901e5d535f78b029c961e78a7a14a263f7fd0662a051f906c723cec102f6cd3e97b27a65910a227dd955ac641aea9a93a10afab08374b0913ece3bfc38ec2279a8a03c539f6e36b3b530dd0148843c29ff704ba16acc5e679b9ad95fbc26339e5f778f94007fde87b3ca4b060e845d395381c875f24e1cc11e2fdd50f88c3f5d697e7996fe447e55e212b72d52928079549127b9fef659472f2efcc83e75c4931af9662b34fec8bd932991ed7f80fc09ae3b25706fe05c832c8d77697f1e6d11b7b12b96ea02b3a8c09042dc34a097603c08d1c94e99b235fb12a726572f91bacecd185be22ab417c322cf4b6dd54537ee39df029adf5f1215642b3c4e8daa1fc2da524e9d96bde9482937e723c0f9dd4da3d8c53842a4779b06a9a557498437c89d3197e0350fc5688f1f0d94314b630215f2a8745d221c916df1a172184cea7fff9782141a264b457b9f79994b6639826cc72d08ca84717969bd340b65dafc6e47758470638725cdcefb411445bbff6ff1c59382377256dcb2d4938c92304a5d406113fc170beae3444791578a78280e7d77d56655f7f533d22340d6c78fbe59807c9c442c992955393e381fa951503634541bb4111f57c74e174a7c965e6f8626c5df0485ae79ed326e50a64941ce8ed1002e0e299e4ef5a05338cd370157773f5146db746c2be3b777bd9e9cdf0b315a514679090643c10c9fbf0534fa4b91d53a04490fc23229443925b1ec2aadff292e70ba9a46aba72b49e1a5f1db4e29eaa8e029acb47dd35d366d7a59c2f08c47f1c21c72b9f1566514d8a6f4920efa18f2c264a55175287d03072067b0b5da5c08c3ce5095c056d0b8bd7f06dcc9662cde911c4a71cff9ea764d9b16e203e79183b2411867f0359644f696c828bed43770c93168d1041b62003573314c1fc3c39b57179523e5689df891cf4aa28f0363f930cf0ab18648636a22d94d0c6bf900ea2b4bcc092b0f49183ac0d512969c966f251c472ae071fe0761989818b6d87be02c37c8d864057a5124f12f87a079865ac3911fd1cdc36e1642f0ef97ecebafa49b0dc6caa51fe191e491902eb60a6eeaeb368faa8cd135aca8d5c79c72223dba9013b7675d965849be708950a135f5fea0f0976ed7556fa2e7953b61b0cc6ca1bf16ec9c230203feae2997254a9dc8ed3f8640d216b6ca545bee08e3bcb1caf501be09464e7ff001a9a001eee595a58ff71cfab52dee972c0ba2a8482881e4c2db16ec16dcb48274297586071a877660895b091fb125a970a841ba844c84ef91ae73b7efaae33a6a70289349df8aec565626128956b6e2b8dc5bb7d90997f0bee561a571c68abb11bf9425781039be6418454bba9c1d70d2b636cdeefe3c3674b789129f8e41ad2902180cc24238098b3f246b0ff32731984b108694e7cf84909d9b5ac438e261951ec202628a98220ea86ed824b6b0323b4ddc8ae5c8bfae21b9844c764009b7ffe9c99d43838344cf57dface9f135c769b677806eaa380c669588b9e91105158975fad3f724b83bec3a603b5a1afa31102218b6684ea23718d536a23fcd6549ef28bd482aa67dcc605b9a11d8e784e023162137563855cb92aae012792719a75a45ed697d98525c80d53a313ae648d246a333c4a726eafcf6a82613fb27cea287323c9b998047f9a8154d9b3898080a251f14300614f665d63e9e4ef63f9a9c76f8fdf9981b7827456718f41f2ae95b20e94e31aedddf874acd4079184f094bbd9d6376c653fcf6b8d059f025e29facd7daa1e7a1451d53b50c105bba2883484f9caea627b31238dce496fba3b3e2fed164081b05d245278a4b554bbf309287dfdb7173eff04addec6ccb1d8dd3347f6c5dbaea0890828a8f2e3fdd44c2a7abc34022aeb0c0904175813b193758c506f9e7675bc512ecc0c17bf1275ee9027d23ecc2c3d5e49c7e3258461874f7fc4d0b001e489bb4c3ccdd4fdd49d762a6b36482fc6a0f2ddae74c3b825cddceb774466e302375f56002d9eaf372cb62516f08a08f8344f2ab9e31dc84e1195553b660c8b567af21f94aa9c678b6c1c148952aeb1202ee8c03ee9a21a4e4edff5df346b5c1dc36d19cbf3343991193e3a4b61378267b4d8b6095dc4ebf4443a9ff501d02396184045d8d269b4b0bf02e63450c2500b02913e24e577aec28da1a7df9fe4c300051b8dbc122607c0880cba4a67a9c862bc2e222c92c2f9b0b199f687776e295fb974e552436efd05e824761e7f83e663dd994f38cf629c1992bfe6d76f3e03cde9dc35f10443b2dcb99fefa3eefc78d9f8d27365f75c12893d2b86dc47f08169588c6d8c2951389c4733363b713022793142f770fe96a0907bca56c2a5a8ea96912be8b18cb755a71a5f768979e13d63a1cfb35d325099c397497b9f38d8a1000dbd4920e8d0c452679fc257feb375a0c2cb0b156150ce6fb8c138d637b80b3afe51fbc692b69c3ddc735ddbed120cbed6d5f49799d1b954c9b430be1ecc654110db566da06115c452bc1c9cf49a2a0f825057556454a6e9d1116bc5730500c58ba6a2421f93000aba9e3da2419d79f9aa18d19b97ea7657f0ce736b117288ac9f02b4b7dfca13ce5689b48bee5a3ac94fd756b965cb84588fe664c63b7f1d818367b430a1a73e20a1b1b72413106505427480180e02757aaf75b33670c98ddeed342e7787ed527019cda2cba90c527bfea846659b91b39adbf0c3622fc10c5c8c1ec4971aa0b1e36b1808c78a57cbef152624111944d2d6bf1d89b63d718c9d8094c79caec756da695e2697488ecf4f791b93d4d062049e23fc56275ac9438fd07d4013936f61b6f18867356156a4093462f038d1c47fce0ba257ec520746d136af782b5ed2b1dc79df76aa87af9c92ad91f9f6cf0749e4e1b484910141c437936cd8c729f669e5ca2c258c4bbe0b2e00f7a70a6313725b7226b7bada0e8ed3234c9bcfb9c0f296e5bb5c450d40d332557b3c76326b7dda466f28489aeb141490325caf7904c452a7d0fedcb60f8158f72a2c8ba8639b457ab69c4e974bcc7e4de08e7b6e56b55f0a3783287049fa1876177d70295319b23fd1ad43ea3c63a1bee3a6f679408d9ddae2545c85d7b0a72937347f014bb0bbd3ccec73bb900113df4554f7438fb19144a7c43e1cff18e3d4504cdc12d7076c6904bc1875987724ca530b65012094b5ea70d197db2a37282cc116da1f326258164c0768b530d6be734beb88acbd68153189239f585a1f4b5215fc03c6f0000ad9f7a1ddf466ba4cc066ff4b2563fba5de534ebbb18e39924b22c78eade920f871c4b073306451efbdb06fd6855255b565bf12e4040b3a806c4588734b519f881be04d74fffb6bf3dc33771972dcd04312565b7a04ede6b688e6b04b7d4f3053093e2762ba3b2a5e40eb1d72b2521badf024d419d3edb1ea02c2d557da41b37db9a16555328a766060fe2e568ca217eff710fa2efa3384a9557fe368d823098cb56b74511fa6e346dbeeabf39c067cffe790ed31cf0cd681e9230e3a3de98b3bc49a48e97b739778599324a9586a7098b89d38de98deafdbaf8879268b75d38d23a3d83ee4371c7142d3d3a42fdadc2d05a7296ab0432e12bf7d0fe7153b2c5b14d4e4e9704dbce0dc57dbb9f7209527aafedca0c35823eae40a1acecd5962b38ff1f9d507646e2cd77cfe9f2a4780fcef5dac093ae30ffbfbaf5de100d62778f3b039af990711a25ee46649e12fb31c2e21544cf8ecaa20c401c2b288a6d68902f5cfe9ad49b3711da4b53e19efdb1c8c196c5fe500a6e7cb09f8cba29d887441d461387a526938b2e7f534de37cafd961bdb9dd4be7105fa43ccb9077873b91f0971bf30551b2d6640f8b98e03444cc3f44d3981091b05b85dfd5c05c9519a13b358b85a2f158e1d62ef49bc61a59ae02f4c57992c3f123f2d0ea3c3551b05be2ef182f101682fc3c8af279b01f1ea333ca293820d3a1f70fc09c42158a726584a1622e62d9cede5cc321236211e52737d54b14f15bec8cc0a74df9fb16d54c39a191319aa94bfddb6736f5872a88a9cbdaad2b0d0aeb2a3fabd9487feef8def938016f54a15f37cc04943f45e9d6e24daff547cc79417067aae679ef592c65f7de182c4ae6b3c57e6ed0d7059a1c03f72c147e8e57cc4d381b187bacee99410cab686ae691e28766df15263df451402c5a0d939c4d8f21e7aff1abeeda1deb8412a9ab71996218285d36205c318f29bc57d5825dd9dce37fe3a81427582ce275a5920abe64cab0c07fb5c785897fb54b9b66cee4da532fa4fa971da782f90acd4965d3b83cd2aefb1b8ca95ad54231ce22dca701aac28382deaec982e7ff10fd03740ebc88dc7a6ebf831b4c83953c6f20977e9cb02375a2bdbf560f902e3b797cefd57f32eea4216336ccab0cb58c858507370fd810172847182aa232e84d2f6640c2f1b1f19a45f1c6a341e680bf4865598dcd5b449fd531a8e579369e1d4d7aeffebef22e477a06db6c741d9c8e4604625b7197fe5113251690e49642efed329da25546c6b343b5741acb0561e49169fae41ce34bd6a4eca1e1b05d8415e93719bbad1a4911f688db849cf9e67392d800d0ecfa89219c1b2271613453b286fde055f8f892c7aa89d1047b481bc93265689aebc9c6e4ec4a540726f5ef93f2485f3342720c624020cde393db4674f071a708dadb73d3cc3673c2ee406646fc0beaae5099ad9a7cbd82d5ca7d20d679ba7331710dcd3ffeb235c7e40b607c5e1640031770862732f759f9b3a00e7f46b5118410e6e0ba98afdd67d445ea0da9db0c522f620bb0d78c04752536fe031028a271e33a5d499390daab1fa7351ba5887549b4e95d3ef8af5684a0a4d1588572d9bf3c5d2a035974642f6e458612f96669bae75b3b03955efcd7526a12d6a08df5ef5362c8682b52b83f3d78719fa08b1f58df394c4e260d5367554e884d79e0c3e0479469f4b99239bbb086a328582e4a5fbb85ae304c799855d86b3830172fcfc040e9b73a9f3dfc1038bf611bd8c4930247cef6c4d0fb1942dc1753592e1d06fe0eea322a4e86d93fd9ca34ef151db93b8069d05cdebdc0f6a47b745a11ece5edb2a80c8a41411cf4d7fba5ab9c34931b777ac49577e8073141b82f5adacefaa566f20f50aa980bf8861d4ed1c6ecedadbf7b9162ff77a5be560fdb4ad87ca933f14584ad7872ef083e46e68575b69958b857c73cc412ad970769a34b436b0e4086676ee31e1d39d9b394a4e8a64165a69e73b4c06f9de241e8507f1e3d86e57ecf71ee0023c7b680476871b54283f17143c51b9497c9748767e8629aeae9ab89ad1d71391a3865b7c5c6405e913a5b9744ba76b9ea477e17df16a142a78909f2fbc4a5103c171c1aa47a5eb63c9cc2f08d8028699019afc458c7dfbe90fe7f4afff25ecb7b23953c8e34e148e968287c3481674f2a4e870bec16a1e059168ca6ca12e20081a227c2f49fda4368f9d676820b782d0896089add98e878b03aae2277553a91116a1d9245036d5f307bbb0017b93899c71595f2039258dcaef741adfae66fad4414853a37bebc227f43ea1810a4cf29a24a5d42b6e03666799d6cf9020f6c43c30e38861e3ae28ca66f8f3abec175c1339cbbc4ef051175b4729b959dc5d84fee4cc4832dd20bddcd2aa9bd5cf6d3ed862be7f372785e87e7212f693168bda12c02995ffa5d97f25178bd13d785a8c8244486aa8bfccad7ccc3202eed2b7dec9cf26a4da5738257f0dbd89ac176ffa4b7c3026e3103bdcfb6d1db4e94c1903990a4a4fc4009373b7a4a47f59a9dca4e2dadd036e93c6876c8b8da4b709c97e8da5492d3058dccbc7959c27b84c868c42905bce92151d60fa5d3a2612098d0e2cbde1f9d61bf85200337abf3ce0a3970347f6e76bae26ef3607ecdddb6f5914cc3fa510aef6c4522d88df5e294f6b0cd6d4f504cba9c4eb34f8bb96111c9f204c3e3368fd46668afb9669ef0f3f121c1ae587a31c499d880851d48b2dcdbb7339657f5e0048397d20a293ee6ac2217c9ed91ea6bc67b3867fe03c4c31713f7e0fa949cbd7722b30f1ac4ec399920c0bc8bdd6197e4cc4c84afad8e67e503026f8cf4ad6d314b342caa83dc4f106d890a8d206b304206b23c5e8e1ae246fb941f20f721c86bf132fe2af64176570391dc31e535a38a1f1d5eacba9efea1c8b5631d473d6d66b4fa056fbd89416e178c8b08736d9fbce7f663f4b38f86b6428e8cdd182ee62fa9d93002a590dc53275ed846826eb53ea49944ad3cd5f5fdfaf9076d4d55ba1d0dd8fd1b868bf63ab7be20502b540640810a266160ee510b310ad760fa16b005ef79bc615f6f6fd9b6c0809035a634b962ad649f98247941e269d19be1b31460922702b0691c242eeda4fb5705b0fe075ff40560dbbdea1347fcb119c65f53eab5e22c5d558c74498991a67c5d451513d6dc81b504eb48d598ebe1fe7582a5fa89fbded0da03f702d73a6d9ff1e3fc1781b618e2bb7ae9d92266c7b4185df0ed041121e9b6d13e4b83e981e632c10216f02e519dd81be0df7ff8157805fecefc9c74c9a538a6a92f6a333e563b017bea2ac9a91a2f29fa5b7a61c4495263e2b28fc37d6114bf96bea5c4c20d1c89a4a035116fc88d2d02cca50761099425d025568cba32430ab6b404879447cb743c8e8b299fd741e169c7a8ebb9beb3484bf7010f6f695c518356e1b0c8e515aefb8a4c4a964d1b2dafd4d56e81e7317e79ac34d7dd337a33ec3e246ee3dc14294c9c19c0f7d81ad28f75707a7aff82d205cedf909a6ff486426b27aa846287499f9235c90467654d5fea5466293545a76f1609a7c17049d8c21c3c2a1af818b006ff55ab2b2dee1f9fc3ea835770c32954fa7c513e3ffe0f8a8a6185236ba9f4e42ff531fb7156e389ba67ec778d824480756bea4141b6e78c26d88be380419876fde1d377c0706b89feb46536abbfdeee259e0c8df0f8d33972ca739ce003e1c74f8988a5a3600152fecb8554665e4b56bd26c3c61862d8c5a2f246d9a376b971aba929b4deb67d1670bd435a4057a8c19b2fd9e67b9a140913d32463c21eaea70b4c274b7d1d05448c363ae8302793198f4fd2b7955b656331e7e842b18f36cc789f0fa859ab10e08719b0b3feeb20232e48b65180b90045f70bc11ead9973ab220ef6c0389ed0251b90660a4bbaf21ab1742c53cb596450ea783929d60216ea9789ed9fa5107426f1f0086b0e1bef2e0b0e136817f338a63a2c25de1742e8fa00fc7dffcf5532ad2139875b9a91d9dbf1e966bb53a09c6a438a2175e22c8ae44eb987f8925f9c09b3b87d55472acf2860534df7e30d70a4fee370f04114cbea8ce1fd6a86434948576a2093228cb9316e3f14d5a7353ba5ef15b3604774a963d360ba6eedfdaa912116214bf0e922d58036425206a383def71652e369b80d9d630b9e750604327dc4c560c70daa8853c80b0d39bfd26fe1a66ed99566101043dc43996c83b6f8e41ebefca5c070da2b90790fd7d821d3d0848bbdb25d863e1a6092845b31de18f12d841f051cdaa54d9c029fb1384847725fbe0ca597486ee3904a40d131c6e766d287d468ebd9ce7c8c5b3ca7e99e9f891c1abb79a4b0b06b4a0158d576efab1dc0b3ed269b78c0b20c6448f5a14b41c52cf20a176f1c737eb9c157093558463a0f6ec7de5f2ddf76a186cef7cb2f459c80ab2b71cdce4113c9a2e1ee5484812d33393086e5aae8c8c5b19e2b09bc879a9680bb0d923032433dd6822494110918211c780a68d0e33a6ae17fb64aab91d59ce2ae5efc65004d182135f222f57f2d9141adeb4facbabfc44b8610e8b12c7db414c0de7dca04f20086433bce59a54a8b26186286bbd9be20931af168e4bffceb5b728086032db3b8c986aa20e6241593d41503891b103f6173632c7b8be41557b9fc83428e917fd535e7dfece56c0be84af4acf7419c4f1f49b4a0e402ea4796234e623c5a9faad781bd53fb8d40da67343a0b0dae83f2f49f5f1bbd4b4bf991d34106a4b7fc5cd0830c5215730b0c441a00debd4a896f1e3b4a9860d73b79878d11bbfcd5783cccc7a2b1f7725b66eb1aaa2fc52eddf20a72d52de3c6ae5bb176e19174fa0b2e1107ef11633d56a42fc64cb6be21c376e24ab3c2182eae18588eafdba51a98400413d660bb198815a7027873a24964358d7e8fe6c1da282af9add9963ed191ee4f3893b4b7a87fc8e0b3387307f305ab4c512b78e8eb8c8af143cf84d056e9d7e5836dc00a1463fe85fc857c56f350e9c8ad38782d4f8626c6173c2e3debfb87dabdda7c6d9b7bee73bf8624c643f2eabb80350782b24113c777290f594b08e97857fc0c2394b72728bd19c9d6f5f0212fb5bd728afdc25681f2f7969a115a0e8fb7573d04e0ec5f2693344ecf185fe29649af2ee5b1a6f728498e0a94e28796d1657252b5c7a4b185f156477c347a5e9f745b9fd838ae4e5c3715bca374c47d298aebebcea6f1a1e95bd793d81f155eeef4ebddcf0e08c73ee6b581ffa9635e986e5be4616e06ed2dac7f84a1e283c4400432afd1053703cecafc23143fff89f49a0a0072d473a57908493f4a87593d2d612a0874bda289e2b30cc84598a594c05db120669c7948958a92d61fd6fe19d8bb23bf06cbded1a0d475218b358fe5b89159b85a3a00f681938b69b3364080151fa0034e46c068ec5eba55850e786bccee01b586d12f8c47a52532d405d734ad07fa398093f06fd059edbcac00d12693a6ff4e5d05cc43de847d2973c6aa91204cfe27862073842c5e06069902de735b9d2e229a860330cb74fc2c3811699d556d7c7d2fa67b162f7ba8fe97b42879258d88cd9f7cb822f5ff51ad88e472b59384505d46999ab08bb8960880a62eb20a405678813c86e2e523dd56b96f37cb33bd07a47b626d656422d015825191597f0ac10a97fc337612fb2be116d6b8c1a8665101d2c9331a3ff444219ff85b694cfd5367eb540d4e8de5610662d6602b3838154dfc50c50597f001854c446b656a789a0998403abde064376b720917056e0f892431286dcb3b819782bc6c2c86fdb2b6d8caee6654b6c0f2963f85dbe05c98a8aec653f574dfd1dc48f4373a1426b785f91e6670e9232059af566462c92339ea0e65b5037866e6103c863c0b916f6b8c1e64c2c18d09688d2bee8ab45c1ae64516880a386fdc8fd6abb34183b5421cd1bd6bc3a6bd18c42acdf00ecf9d54e7d7cf9baad6dd87d588708f0c25286c072eddef604095c502c06f93138da2c48e6f12a55c78b80d66c6b243f8ff52a23d004ce3f054a8ead6244769a12383e22ea7c6caeb69dac59e475137db25b485841f4950b402d6f8585b9d63c33934cfdfc3c25ad832c58d0d971ef6b0232d6d0ed6663f19ee7f05b516c96ce9a132b46ba7392413d5f9b0a3b2622c2b68d60066ab2e0de69cf9723287185d4b52dfa5c77165cf513d46195a640978f74c4035ad78e1b674b8839bbe0b2c3323c5e8a37226e18eac17f59d96a0d537afac7cf42a2a619c84763750f7d4094a766b87f1f339b4e7f208bd88b5a077103b4662aecf0c4d85068b0c457b34c9fa480e189deb4e14397262138e437e66936031f6bd067fc39ae58656f31fa92adc66c3c072ece0c2fda2774ef9c4647160f783e29292fd81587f4022b92a52508c9220152d6687408f45fe6dc981b61f360eefdbcf24b091ec76e76a7c4f022db43747fae04009c39e6659ace27f06503a7fcfd61bad2bb517d50fd4800a3ad28f6321ce9fbeeb8cea40b2f08b0d2febf60ad3183030395727975f2e703a9802b518dd7f3d515df7bab0bb99196b71ac5cec7e3c0e0b286d2f0ea6c0324044c115b9904dbf808c286f4247eb03677323f5247e7065ab546a8f03ba1cb3f6c21e4647a47971e6dada4345ab208cd7c5f0490a4d6849c9c93cfb2d43724d59a1fab773192805d3165c011d8801631cdef632ffb1b6dc54dc81e8df190b9a598e8a472f859073f3cc64f928aab6528ef978500e2724b0dfe5390ccee960d77bf8e1f29108ceb49d404dce0d026c44ff802149631d75834f760ad14013a04a9a3d172e89d92d6bc98a20979caf8d340250979030ce2fa4017fcb978563efb96980f9b78c19db86deb50828f56a2189a395af1471993fe16c0b28bef78b61d6db265da2d092a886c932328f99c8732ebc90b5bd9c7712d480680192e9df6867218d9cd16704f696641306defb15ead2fe60328d308e49c8ad8dd8988dc785e766dfb2446c7164f7aa9ea721eca550472d29887a109191ba2693fead76e444039976ac41b4675a99537c9986a264932c8a959acb293dac4895c0eb851656f175b5ea976e08192e014491d2360d23eb1e1c1c2891c17cfd32ffcde0f283540ed9fdf7273a38980b1cdc303b3631f430a2477f804098754bf88ca7fa570019024bb4171116755a72e502cd766ed7f76ba75bc4c4de9d0627124e4f9c283006c3f9927f94e149c3d6596f29c8681bfa74df4ed673aa20cafd4dd9a06cc2d333c2dcd91a91a81c7aff4b7a21bd9a2d7249853274fe14e21fb8e43386b00a24ce4fb92219537a7d82aa9ed7fc1dd085e36761a4e6822cbc7aefe6643a5427c8d82f917470af28fdb3969cc82156e4dd97e6d7250e36a89eba96fd1bf0d28fd068342e84527cae4b53f74eec76f7cbdf0e1b1fe26517c74b489ec0902f60a08af5223e61dea06e147208808ebabd917aedd6e1c540a2956920d2363ee90874f05b62d8d2516faaf8d7445c6646b5787691ce9e380806630119615564ea7332bfc6c59550f53cb0f5284bfc1a85fb0117184bcd43555503018cc2bbc89d7670aa94ec5033bcfa70739fa9dcb2d752f54fcc1d7129cd6c1685d69b4042e86246d6a16efb0322654fb44b831edcd06dacbc2905b31b76e722b024cbf02dfcdf7504fa98812bda8d217183a1c24d296094e678108d256b1228e684ef6f89c5410e58e216141f0a88b380e95003e8aca7fdc828135275251da3122c39b855e2f539f073c95675be0818653b429f1651ed26728a8902c016841c2b124a5c7de20f9f5ad0e2cb5feb0bd58e05461b3681a221be90ffc996ca0156913622175ec0bb0a5e9e41798a8424e57e72cce433770154a3283227ad7280b4cfea01762fe18cd63b341433f15c4cf3eecc5aef99a313a55da010fe052a894aa2483f3be3eae6dee2df4c36d505e1f4878de0d2a11dba2f53ea377f4b7edb89fc3d39440cbff9a42fc3ae105e63201ac3c3447666f57ef5ba07880f903ac49978e190172774f7e9a526316a349c6ab4747d2693d37604a4a6aed99f44012b92bd003a5fde42ac51a1dcaf81c1cb22e44f65c7bf1a2ef877b5caaa7c43e1dea921285c71367ee8a4f2bc061a4101b9f9f04c4960d7a1ecc1511eea4437612475156a2a31ea6f7362fb077b412ae908ddad943bec09476c53d2bb7ee0985e142d7f92125c217d586f94074856ee604f29d01a2eb959e3ccaa202e56fcee84f221ac01d84ebb49e5a6b9b179e43c35ef16f24fce6afa5c182fbd2e2a2d1d97c1aca22f84f4ca93e5bf604dd3eac71e9948a2cbf1203167e308d850c651306a3a04fbf9403735e37b97f6e7bc9d15e760de450f5a1e6d35d46e913102dc4916fa97ccdff3d7a755ffbe9218eb9b20aa9858f36fc141c653680644ea5e3083de33dcc658daf77e824c5c87f1d66c0af123b17704479d651a35ba646288eff62d05f1683ceec7bc82c185850233733543c976836f2140996afff64b15ec70cab3f80d071afb732642e37af006c96fe01589cb93247fa7852fd93b72eaccc5ad1e3932cb7978fae476c3363512e11f71ba7c5139d750266a31bad5339f45b2a1eb1b92a8d714f2eeeba58966939d72d33bfb9f75d0be8a476ca8c26639d1b2b2667b9c28647c50098368160a74546378ea864bfc371f56c3448be0b66cc3a8c8b43265707612cee828a8c9ad5fed4a503cc326ee177addccf98555988fa9bb7beecd93ef3ea23983f4ec6082ac56b4f7cbe6c732ee1f93347cd0cf788227eb12d982f49340a28db2907a080b5ba8621226c8a8bf1f27333a7b336e6b402f453ee84035318fb3a52c33a94c3b5802315175740f9949447f76051b96b6ff77902bc777f8c95d6c4f4f4819bb650dbfabe9e40e9c86bbc9e78fd803b573be1da8711c9e67fba40cd7021989f4a8bc317b94008324317fd1a244d89f0b448befb004ec0075bec81e90dea0fd71930a8b723a465e76522a1bc780d64f1f51ab1333016ec9c314d6dcdd5a76ef55eb0531240ad85b35f914f703d20cc73790fb1e7aa34570cb39952def901b2553f01ed3ff5f5cac73978e8611383c6e0db870cb27d7f17bc52ee4efceac01537fd7ddfe9e6e388c938cae57310a6e10c8475587c8b746e6fd629ccc0a2dcbf804c522c3b080df42d1138a8b7b921b8bec06f7424434b5f2bd2a7e6c6cbc33f7b9a215bbbf7660a164ca40334c07356e61026021ca95b34de6c6a775ef8c6bd22504ff555e9881bd78789531abb590ed4b1c6e92c9b2940e7a699c605b3f4c3ab639cec44d43b923ea0fceda80348e36184178ba94e03a31def2286910796565371d28242de8628bfb83bf2330e59588a779a870e5c2d2549500d09df2156f93f6e4827fbb8725c935130541de4b31dc242681105ebf54bf2bc26838c076e82a710dec3c053e97f5b9dbb3d5f087d244e00a6217bcb384c197a299457ba41b9680eb6723c1232e57f8efffb0e4e021da8c254f103d67fb842a7aeb51dcf192f8cfac850432470aa2af0eb059a9f4128a88920df99cfd674ffd00b4039e5435a02d4c6a5fcc708e83399f2a0a11359871dc890dd8e7d228423d561a1f5d814f66ba9d0b7b900a1bd004bdaba19882a245a6bf2c09976f83027fe94d6e7853cc9c77eac81f92d87156c352053385fe093434e291cc93e87fd637792272f8e683b94939fc95d455ccfb7094fe93966e628a041555e8f916b66d249ac0c3b62011d9f029139d92e1a2d0c99e84441dfd562f9a0aacc820442d9bd03c89cffe1e85493d78dd20cbf36bdb9d88e420673b1a1f189ce1eedfb6eafc469d07b6dce51166d836bf36e6933cadcad63e292d993fe8749f9981e913acc12946b69e4a33bc079a3e104e91d86c66b76b2c60700dbb8eb09e1f7e8870338ff7f1f6e0b7500bd35bbf9106bd4e3ad126dfb4fd06f0f9e0e7a6457b1de66b6117396a86adafc1854e95a03491bd0fed81fc62d312c01912e70703c801af737cd81a78cfa255304f0fef69cc92b33796587dc17dd952870f68927353bbb867df04b8d44943415330ccdd827198129819667a81aef2f86ccc64be8c77c402e1bbb3f67838bbe48daf61d39b27177391fc7fc0130539061f69055d8b906b03cb225c8fd01b41c6cf4c6035c0b6c6d763f73a9453c610a372ee17b42399a1f49fb632afd4d89b57283c110eddd9ec102bb6d30511843011a08748318a368835e5b59316579f74d9d74b68710e567795c66e672b9c86cdbb443af25e2f267754f8b353a45561d53ff1f204890334e179a3a9a6b5ba93b91e3fd1f7be2cfff3653641252dd60aa8f6257926bfa8474772507482afa37b4566c2765bde0cee3fb4988ed1d88afc865b2d2bc3ba1a3a49d9f758bcf9d3c69301309b2e5137129e3b53c53d8ffb505d9b29e66b776a10b6d4b31f1806d460345d2fb09d71631fc23eb9f696c6a2d6f7af6269991167a174933059c06e43b15b181b0a564d777d8d5eecc5cfabdc7ae24f64f9eb0c863e782019fa4c0195fa3b7d7ea06e74f69e8f930be0e6e35930de7d6c87b1cc6ad6d3fe0a845054c37369fa00af3df51ffc1411acbab206962a16c388357c2fa1b6f7944ac1791a78264412aa09a22254362b6be1b754a18f46bc13197e2326d2b9ef9ec35c84242bba3e59b5f6d7b0f90bd98e2df31cdf860e4be13c05295796ed5ddb22617f3cf88aaf3e31f6277a51758f03c13b5f33ec1e88478da2ca2388842e08d354caef6c3d874c2907994d84b26222d1aaeb79439699861a4da8a08327482d1393c92def44d7e6e1d761d444331d4570ca7b2a50b7eeab94dac8012b273f075af4c64d7ae3b65583867053ecb0745f587497797e18a2472bd485c495c9c6da00f1ee64886550b933ece7c043e1801f88e98222db51de92649502a7d8fdaa487d03eb3d44628be00aaa2255ba5d741ef198304654296e3a2aca54e2d8d489f5ae44c0fe6ddbfd1563defa380c65ec998d8be79f4e62ceeaf3c3ddff777559cfd9c726d67d6142c1d95842edec0cdddd09e7df39de1877321392b5c3aebeff21d7e63aa9e26c3ad6037d71ffec917cbe9a523dcf09bba1bb364ccdaee27ff662a789a0f1d62ddd24c5638ad7139b40b3822bf58ed24bdf3ff9646abf6336166bf2fff1974bda15be2652ab378b648252fcc8999f4559ba4a3ad964c453eb37ecfe714b25aa425eae44ae653b7908a6bbb789d6591d54a25964384fb06f477c60bda310b50ef62405c808b436366b237800ec483f6e8d6061e194380524d2861b7f3477ca5e3c27d083a3a6ae4b0b23f11adbaf395af5f01e8f893cc817a1af4c3a699184444f455ee7f4af0532bab25dffd024a8f6fe193960142d04fc018287c0e63641328cad282ad13e74f4094cea2a9412f3b9b3ef8dc350287ad82b84a02d376f770e2039a9577e3272b4779fe41738a37bd7f51cf09a059e28c3f831eb1c9580c039e2b97aaad81baf658e7b27caf567d8ac16f30cfaaeb4bd57addfd7ea22075ff725856ba4dc9f97216e5d228591354a48b99496ef53e102b94a9acbdf89da57750aa0e84b42db030ddf718df5d2c12e854c8d9285e659adf0df8e08fb57f75d3acdd51c41bf4ced7c372c4f62bf08c5d5e077c13c62e546a2df6cd2db9ad0ccc986380d10f4ba91777979a6bda1cf0da73af544021bc57a86c622007c7fdb1823a41675e2644fe9552f0799a27052c3a6bda7bf655341f7a0068fb0ccbe4ae386a11d3dad29819a366a3b952f7ab1b27fe556d3400848e25e29e6ba9b57d734893614b35d4a72b51e313e2765f75f1f8a6f9d64c707a1736e6024834a6f6175cea45d8ca56f0d603d172273fe737a6f1230705cc75018ca565915bb47d4fa04439fefa1526838404c1e5c6e5892080c98fa0ed36479bf5dc9b6f2e7c74c37f596dcb40f5c9c866feafe69ef211723f735db25df9febdd75c0d1e42eb18401874691740cc93cba8de9efc83b364ab7fd47d505db8f6e212f8efd53b5d2f0f2df2628d3bf0b9bff57c2cd1795611943ee4bd2d112a2e58beeab8cf04248ed6a0f65e0473ac74d13426457fac11e21995f6fb7ac7591d9f2b9ba6d54b22c3b407f98e537449945ed0ab7f5c05293d66e7d5176c0bff882131fcf73c4116a42879c46f2874a27135cc0a236aafa74354ffdb79ddb18d28092f0590d755fe0842021e95ee87fbfeae8b02f62196202f474dffaf96ca3bf317c797c1b2d2fc69f2f59cc8deacf6ad099aa06c5e8f497b0373fc9f8cbdde0d57bbb00901c705587569422501d7ce1c8006a1edfec546a6da2d1634843276134bd0d94af5d4a0649c41d25cfff9f44063199bcb394b2ecba4a8034b9a0f3aa1fe5d0cb2c0085f48c7e39477b14c54e9d784cc2380275ad00d110382a75f4381890cd883019c5571c5c3da16c59824b09264a3837e551e19f3ceffd97bc13ae63febef345c61169c194e6d343fdfe252403cbf2494d567a3e188e946f12e44a6c33f108db2d060493a768b1bc66527938d9e432d7ad1c60a67372f6a7feeed523499fa960e5e5862ae83f1822d80ed384ecde9326acef10c3385d9fb87ec1edb1725b3b419e307ba5e15554c89d8c8f387f9c07d4343e0a8e1fbe6dfa4bbdb36ba574057624f53221ccfa493ec6f37323157c1ce428abdca121ecdb05014a4a43f7548cc893528d9e7803658e42d6735852b9f3c8179c2e4f9d962fc987e61195c791eaf99eeaa8608369b53e74d8b33dfaca99ccc8a9581d9fefa8a3ed7acda631e4a08b70e3e5746127e5ae81693c619bc5ad9e755d03b1739e2a5a4edfe93e27cc2ab4b90d91b10fa90cc66b8b9f89bfe9eff5251594db2156d8c10263f7a8b597bafb89fa21ea62a2cae286344c376d790650d5be853ac756c9ae31bff5f5f9ad7bb80ef489aa1bbac478c02d12b096f3f9dca952accf71edd1773e851f693009754b692e8864e532ee94a3316c369f5479e5ed92f7c1937096a39481e976b6971a42405938810854d31da3a786a502e9713557d2e2acb1aa3dea6c53143c67c3a53e504cbc00a7cba152b495c77e0bca21af7e3737b79fa6bc6676651d39e2eab15bf2d388fd00a27827294a7356cd2d54916417c4355ed4d166a5f64a344dd7508f914103349a66338d4a699fc13ca68cce7c69a33901ebc5d9d8a8f7911a36c5a5d1df9d27470b22bec6006e9406d489eb526cc6263508cd8126c166058c91975a1e09ab4e06ad3ee36da2f974fd40f803d131120de7c2a6a05dbb706c5a48bccf6fab142b30b4d9c08107841c6ec6363b57921cbacd55066c159714143fe42f22d9f5c0d61df36b4d15e0b4daa1b1105dd3084803b20d47663c93c016a991a483e6200b2d321836fabdb752471c6b502ebca9c39c2a807efe0ecaca481e91a64d248e8a691fa323239c5c42894ca8f9b72da6a97879389be94ed6efbeea665f7f4a36f0a0effd5b62a4078806fb22ea5810488df7053c0024479752d219556289db81cc40466e4c86f84861bfe8439d4c564bad005573939495906ffa709df080cc3b087ce28451b08ba366cee02c784ab6cc1ee028f4125d69088e95b1c5cea339b3610bb614c04a29fd97e737073dbd43c6b4c36be72e7b589eb44340398fd4d20e63076b0ca6dd09e3a9117e1388d5226763fc3aaed2c7017692ec8880f8b25d257ad992edddb2aec15e3e37264d4820bbc4a089d78fafc42336e713e1ecf301f701fbc6628ed3f1fbf76034c77ae08ca5650aa5582996adc020c299899b285288ce7574e94b0678d26b1653b26939ff53a4ddb86cbfdad565af37523fbcca886c84fb70d34f3e312071202c098c41b5658d850253f5a41fef6e7b57b9526287226da44b361f249f486b6859159ea4ffb4b7c3aa1d9fab6b476267a887e301b56108db2cafc1a6e22a4a84443213c0c6196eef12a86036745676f2f8b299c76ad17a9e5350c3ae72dc00b9d72a14cdf87babda3e8e7d5f586243fa6cf8175c51ce9c273be139502d0a862dac4951225af4b4f36eb63a044d285b9fe00b01c0a97e12d632846efab012a17655c659ad9d228f74e723d95ad5f8c5b088382a7ced950cad8c3e23c2fc776a4a0969434e262dc27f7bde76cc2fd224950a8c89ee8e25b64bd746d67420183a797231e7dcb765eb25be3313d86921537b574402256b63869860389d7b54aeb79104ac0c95083b30c85086d3111a854809a004fa783b611c86632d171640268db84e04ffaa627a3b8ebca86a6ac4c61d8f1cd90f5b70dc46813875d4b2547205496eede486d1e16275e9bcc730cdb1a183d0957a0bf4fd0a66c06b1d750b0356edefe62f43f6baa4d02a92cb23ef82cec0881fab664f1e076bc3e585a0442ec32d0f4778dabc4265918801bb98b5b71112b6089ffdf088d4dae7c2ed29c37a3bfedb381cc1c2ca79be2c534555e0265a44fbcfe08a57a2256a383b851432cf55268884134d2f409951c953cb6d023685cf21a6aa6b034312207a09c68300632b7f3baf7f9b0cf49476a7e315031f158dd7f0ec9088c67ead7acbe1e93211a9db136f8594e01781e889bbaefebfd7c3d6e94d0670990af67352b8ada3c8aabb0ff10db1c4094ee04cbac7efa5701731fd1f75ab574c1f57c0a84dcaf02fb838886c7434f6d43386771bf3414dcd5ecfdedd14d5641fcc7b98e641c45547a85e70a3c655aa348127074ad696f66a0f3bc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>traveling</category>
      </categories>
  </entry>
  <entry>
    <title>问题求解笔记-近似算法</title>
    <url>/2021/05/18/approximation-algorithm/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><a id="more"></a>
<ul>
<li>$U = (\Sigma_I, \Sigma_O, L, L_I,\mathcal{M}, cost, goal)$ 是一个优化问题，$A$ 是相应的一个算法。对于任意的 $x \in L_1$，定义<strong>$A$对$x$的相对误差$\varepsilon_{\boldsymbol{A}}(\boldsymbol{x})$</strong> 如下：</li>
</ul>
<script type="math/tex; mode=display">
\varepsilon_{\boldsymbol{A}}(\boldsymbol{x})=\frac{\left|cost(A(x))-Opt_{U}(x)\right|}{Op t_{U}(x)}</script><ul>
<li><p>定义算法<strong>$A$对相对误差（relative error）$\varepsilon_{\boldsymbol{A}}(\boldsymbol{n})$</strong> 如下：</p>
<script type="math/tex; mode=display">
\varepsilon_{A}(n)=\max \left\{\varepsilon_{A}(x) \mid x \in L_{I} \cap\left(\Sigma_{I}\right)^{n}\right\}</script></li>
<li><p>定义$A$对$x$的<strong>近似比率（approximation ratio）$\boldsymbol{R}_{\boldsymbol{A}}(\boldsymbol{x})$</strong> 如下：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}_{\boldsymbol{A}}(\boldsymbol{x})=\max \left\{\frac{cost(A(x))}{Opt_{U}(x)}, \frac{Opt_{U}(x)}{cost(A(x))}\right\}</script></li>
<li><p>定义算法<strong>$A$的近似比率$\boldsymbol{R}_{\boldsymbol{A}}(\boldsymbol{n})$</strong> 如下：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}_{\boldsymbol{A}}(\boldsymbol{n})=\max \left\{R_{A}(x) \mid x \in L_{I} \cap\left(\Sigma_{I}\right)^{n}\right\}</script></li>
<li><p>对任意的实数 $\delta &gt; 1$，如果 $\forall x \in L_1,R_A(x) \leq \delta$，则称 $A $ 为 <strong>$\delta$-近似算法（approximation algorithm）</strong>。</p>
</li>
<li><p>对任意的实数 $\delta &gt; 1$，如果 $\forall n \in \mathbb{N},R_A(n) \leq f(n)$，则称 $A$ 为 <strong>$f(n)$-近似算法</strong>。</p>
</li>
<li><p>一个例子——生产调度问题</p>
<ul>
<li>GMS</li>
</ul>
</li>
</ul>
<ul>
<li><p>$U = (\Sigma_I, \Sigma_O, L, L_I,\mathcal{M}, cost, goal)$ 是一个优化问题，$A$ 是相应的一个算法。如果对任意的输入对 $(x, \varepsilon) \in L_1 \times \mathbb{R}^+$，$A$ 能够在至多 $\varepsilon$ 的相对误差内计算出一个可行解 $A(x)$，并且 $Time_A(x, \varepsilon^{-1})$ 可以被 $|x|$ 的多项式函数约束，则 $A$ 称为 $U$ 的<strong>多项式时间近似近似方案（PTAS）</strong>。</p>
<ul>
<li>如果 $Time_A(x, \varepsilon^{-1})$ 可以同时被 $|x|$ 和 $\varepsilon^{-1}$ 的多项式函数约束，则称为<strong>完全多项式时间近似方案（FPTAS）</strong></li>
<li><em>所以 FPTAS 应该是对 NP-hard 问题最优解了。</em></li>
</ul>
</li>
</ul>
<hr>
<h1 id="优化问题的分类"><a href="#优化问题的分类" class="headerlink" title="优化问题的分类"></a>优化问题的分类</h1><p>（建立在 $P \neq NP$）我们将 NPO 问题分为五类：</p>
<ul>
<li>NPO(I)：所有存在 FPTAS 的NPO优化问题。</li>
<li>NPO(II)：所有存在 PTAS 的NPO优化问题。</li>
<li>NPO(III)：所有的优化问题 $U$ 满足<ul>
<li>存在 $\delta &gt; 1$ 的多项式时间 $\delta$-近似算法</li>
<li>没有 $d &lt; \delta$ 的多项式时间 $d-$近似算法，即没有 PTAS</li>
</ul>
</li>
<li>NPO(IV)：所有的优化问题 $U$ 满足<ul>
<li>存在多项式界的函数 $f : \mathbb{N} \to \mathbb{R}^+$，对 $U$ 有多项式时间 $f(n)$-近似算法</li>
<li>不存在 $\delta \in \mathbb{R}^+$ 的多项式时间 $\delta$-近似算法</li>
</ul>
</li>
<li>NPO(V)：所有的优化问题满足，如果存在一个多项式时间 $f(n)$-近似算法，则 $f(n)$ 没有 polylogarithmic函数界。</li>
</ul>
<hr>
<h1 id="近似的稳定性"><a href="#近似的稳定性" class="headerlink" title="近似的稳定性"></a>近似的稳定性</h1><ul>
<li>$U = (\Sigma_I, \Sigma_O, L, L_I,\mathcal{M}, cost, goal)$ 和 $\overline{U} = (\Sigma_I, \Sigma_O, L, L,\mathcal{M}, cost, goal)$ 是两个优化问题，$L_1 \subset L$。$\overline{U}$ 关于 $L_1$ 的<strong>距离函数（distance function）</strong> 是任意一个函数 $h_L : L \to \mathbb{R}^{\geq 0}$ 满足<ul>
<li>$\forall x \in L_I, h_L(x) = 0$</li>
<li>$h$ 是多项式可计算的</li>
</ul>
</li>
<li>$\textbf{Ball}_{r,h}(L_I) = \{ w \in L | h(w) \leq r\}$</li>
<li>$A$ 是 $\overline{U}$ 的一个算法，且 $A$ 是 $U$ 的一个 $\varepsilon$-近似算法，对某个 $\varepsilon \in \mathbb{R}^{&gt;1}$。$p$ 是一个正实数，若对任意实数 $0 &lt; r \leq p$，存在 $\delta_{r, \varepsilon} \in \mathbb{R}^{&gt;1}$，使得 $A$ 是 $U_r = \{\Sigma_I, \Sigma_O, L, Ball_{r,h}(L_I),\mathcal{M}, cost, goal\}$ 一个 $\delta_{r, \varepsilon}$-近似算法，则 $A$ 称为对于$h$ 是 <strong>$p$-稳定（$p$-stable）</strong>。</li>
<li>$A$ 是<strong>稳定的（stable）</strong>，如果对任意 $p \in \mathbb{R}^+$，$A$ 是 $p$-稳定的。</li>
</ul>
<ul>
<li>$A = \{ A_\varepsilon\}_{\varepsilon &gt; 0}$ 是 $U$ 的一个 PTAS，如果对任意的 $r &gt; 0$，任意 $\varepsilon &gt; 0$，$A_\varepsilon $ 是 $U_r$ 的一个 $\delta_{r, \varepsilon}$-近似算法，则称PTAS $A$ 关于 $h$ 是<strong>稳定的</strong>。</li>
<li>PTAS $A$ 是<strong>超稳定（superstable）</strong>的，如果 $\delta_{r, \varepsilon} \leq f(\varepsilon) \cdot g(r)$，其中<ul>
<li>$f,g$  的定义域分别是 $\mathbb{R^{\geq 0}}$ 和 $\mathbb{R}^{+}$，</li>
<li>$\lim\limits_{\varepsilon \to 0}f(\varepsilon) = 0$。</li>
</ul>
</li>
<li><em>观察到，若 $A$ 是优化问题 $U$ 的超稳定PTSA，则它也是任意 $U_r$ 的PTSA。</em></li>
</ul>
<hr>
<h1 id="对偶近似算法（Dual-Approximation-Algorithm）"><a href="#对偶近似算法（Dual-Approximation-Algorithm）" class="headerlink" title="对偶近似算法（Dual Approximation Algorithm）"></a>对偶近似算法（Dual Approximation Algorithm）</h1><ul>
<li>$U = (\Sigma_I, \Sigma_O, L, L_I,\mathcal{M}, cost, goal)$ 是一个优化问题。$U$ 的一个<strong>限制距离函数（constraint distance function）</strong> 是一个函数 $h : L_I \times \Sigma_O^\star \to \mathbb{R}^{\geq 0}$ 满足<ul>
<li>$\forall S \in \mathcal{M}(x), h(x, S) = 0$，</li>
<li>$\forall S \in \mathcal{M}(x), h(x, S) &gt; 0$，</li>
<li>$h$ 是多项式时间可计算的。</li>
</ul>
</li>
<li>对任意的 $\varepsilon \in \mathbb{R}^+$，任意 $x \in L_I$，$\mathcal{M}_{\varepsilon}^h(x) = \{S \in \Sigma_O^\star\ | h(x, S) \leq \varepsilon\}$ 是 $\mathcal{M(x)}$ 对 $h$ 的 $\varepsilon\textbf{-ball}$。</li>
<li>$U$ 的一个优化算法 $A$ 称为 <strong>$h$-dual</strong> $\varepsilon$-近似算法，如果对任意的 $x \in L_I$，<ul>
<li>$A(x) \in \mathcal{M}_\varepsilon^{h}(x)$，</li>
<li>$cost(A(x)) \geq Opt_U(x)$ 当 $goal = maximum$，$cost(A(x)) \leq Opt_U(x) $ 当 $goal = minimum$。</li>
</ul>
</li>
<li>一个算法 $A$ 称为 $U$ 的 <strong>$h$-dual 多项式时间近似方案（h-dual PTAS）</strong>，如果<ul>
<li>$\forall (x, \varepsilon) \in L_I \times \mathbb{R}^+, A(x, \varepsilon) \in \mathcal{M}_{\varepsilon}^h(x)$，</li>
<li>$cost(A(x)) \geq Opt_U(x)$ 当 $goal = maximum$，$cost(A(x)) \leq Opt_U(x) $ 当 $goal = minimum$，</li>
<li>$Time_A(x, \varepsilon^{-1})$ 被一个 $|x|$ 的多项式函数界定。</li>
</ul>
</li>
<li>同上，同时被 $|x|,\varepsilon^{-1}$ 的多项式函数界定，叫 $h$-dual FPTAS。 </li>
</ul>
]]></content>
      <categories>
        <category>problem-solving</category>
      </categories>
  </entry>
  <entry>
    <title>Python常用内建模块</title>
    <url>/2021/02/25/build-in-module/</url>
    <content><![CDATA[<p>参考: <a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰python教程</a><br>学习完了python基本语法，更重要的是对python各种库的熟练运用，本章主要是对python内建库的讲解。<br><a id="more"></a></p>
<h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><p>datetime是Python处理日期和时间的标准库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now() <span class="comment"># 获取当前datetime</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(now)</span><br><span class="line"><span class="number">2021</span>-02-<span class="number">25</span> <span class="number">14</span>:<span class="number">18</span>:<span class="number">54.205754</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">type</span>(now))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">datetime</span>.<span class="title">datetime</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意到<code>datetime</code>是模块，<code>datetime</code>模块还包含一个<code>datetime</code>类，通过<code>from datetime import datetime</code>导入的才是<code>datetime</code>这个类。</li>
<li>如果仅导入<code>import datetime</code>，则必须引用全名<code>datetime.datetime</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></span><br></pre></td></tr></table></figure>
<h2 id="datatime转timestamp"><a href="#datatime转timestamp" class="headerlink" title="datatime转timestamp"></a>datatime转timestamp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt.timestamp()</span><br></pre></td></tr></table></figure>
<ul>
<li>注意Python的timestamp是一个浮点数，整数位表示秒。</li>
<li>timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</li>
</ul>
<h2 id="timestamp转datetime"><a href="#timestamp转datetime" class="headerlink" title="timestamp转datetime"></a>timestamp转datetime</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">1429417200.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t)) <span class="comment"># 本地时间（当前操作系统的时区）</span></span><br><span class="line"><span class="number">2015</span>-04-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.utcfromtimestamp(t)) <span class="comment"># UTC时间</span></span><br><span class="line"><span class="number">2015</span>-04-<span class="number">19</span> 04:<span class="number">20</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<h2 id="str转datetime"><a href="#str转datetime" class="headerlink" title="str转datetime"></a>str转datetime</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class="string">&#x27;2015-6-1 18:19:59&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(cday)</span><br><span class="line"><span class="number">2015</span>-06-01 <span class="number">18</span>:<span class="number">19</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串<code>%Y-%m-%d %H:%M:%S</code>规定了日期和时间部分的格式。详细的说明请参考<a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">Python文档</a>。</li>
<li>转换后的datetime是没有时区信息的。</li>
</ul>
<h2 id="datetime转str"><a href="#datetime转str" class="headerlink" title="datetime转str"></a>datetime转str</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(now.strftime(<span class="string">&#x27;%a, %b %d %H:%M&#x27;</span>))</span><br><span class="line">Thu, Feb <span class="number">25</span> <span class="number">14</span>:<span class="number">18</span></span><br></pre></td></tr></table></figure>
<h2 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h2><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(days=<span class="number">2</span>, hours=<span class="number">12</span>)</span><br><span class="line">datetime.datetime(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">28</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">54</span>, <span class="number">205754</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拿到UTC时间，并强制设置时区为UTC+0:00:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(utc_dt)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> 09:05:<span class="number">12.377316</span>+<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="comment"># astimezone()将转换时区为北京时间:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bj_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">8</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(bj_dt)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> <span class="number">17</span>:05:<span class="number">12.377316</span>+08:<span class="number">00</span></span><br><span class="line"><span class="comment"># astimezone()将转换时区为东京时间:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tokyo_dt)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> <span class="number">18</span>:05:<span class="number">12.377316</span>+09:<span class="number">00</span></span><br><span class="line"><span class="comment"># astimezone()将bj_dt转换时区为东京时间:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tokyo_dt2)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> <span class="number">18</span>:05:<span class="number">12.377316</span>+09:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<h1 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h1><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>
<h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><p><code>namedtuple</code>是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point = namedtuple(<span class="string">&#x27;Point&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。</p>
<ul>
<li>支持<code>appendleft()</code>, <code>popleft()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;x&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict.</p>
<ul>
<li>默认值是调用函数返回的，而函数在创建defaultdict对象时传入。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(<span class="keyword">lambda</span>: <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">&#x27;key1&#x27;</span>] = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">&#x27;key1&#x27;</span>] <span class="comment"># key1存在</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">&#x27;key2&#x27;</span>] <span class="comment"># key2不存在，返回默认值</span></span><br><span class="line"><span class="string">&#x27;N/A&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h2><p>使用dict时，Key是无序的。如果要保持Key的顺序，可以用<code>OrderedDict</code>.</p>
<ul>
<li>按照插入的顺序排列，不是Key本身排序。</li>
</ul>
<h2 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h2><p><code>ChainMap</code>可以把一组dict串起来并组成一个逻辑上的dict.</p>
<h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&#x27;programming&#x27;</span>:</span><br><span class="line"><span class="meta">... </span>    c[ch] = c[ch] + <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">&#x27;g&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;o&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;p&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.update(<span class="string">&#x27;hello&#x27;</span>) <span class="comment"># 也可以一次性update</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;o&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;p&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;h&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>language</tag>
      </tags>
  </entry>
  <entry>
    <title>问题求解笔记-代数编码</title>
    <url>/2021/04/25/codeing/</url>
    <content><![CDATA[<h1 id="检错和纠错码"><a href="#检错和纠错码" class="headerlink" title="检错和纠错码"></a>检错和纠错码</h1><h2 id="最大似然编码（maximum-likelihood-decoding​）"><a href="#最大似然编码（maximum-likelihood-decoding​）" class="headerlink" title="最大似然编码（maximum-likelihood decoding​）"></a>最大似然编码（maximum-likelihood decoding​）</h2><p>所有的纠错建立在这个基础上，按最大概率出错位纠错。</p>
<p><strong>二进制对称信道</strong>（binary symmetric channel）</p>
<a id="more"></a>
<h2 id="分块码-（Block-Codes​）"><a href="#分块码-（Block-Codes​）" class="headerlink" title="分块码 （Block Codes​）"></a>分块码 （Block Codes​）</h2><p>($n,m$)-<strong>分块码</strong>：被编码的信息可以被分成多块 $m$ 位二进制数，每块会被编码成 $n$ 位二进制数。</p>
<ul>
<li>编码函数$E:\mathbb{Z}_2^m \rightarrow \mathbb{Z}_2^n$</li>
<li><p>解码函数 $D: \mathbb{Z}_2^n \rightarrow \mathbb{Z}_2^m$</p>
</li>
<li><p>编码字(codeword)：$E$ 的像中的一个元素</p>
</li>
</ul>
<p><strong>汉明距离</strong>（Hamming distance）：$d(x,y)$，$x$ 和 $y$ 不相同的位数。</p>
<p><strong>最小距离</strong>：$d_{min}$，所有不同有效编码字 $x,y$ 的距离最小的。</p>
<p><strong>权重</strong>：$w(x)$，$x$ 中 $1$ 的位数。</p>
<p>一些性质：</p>
<ul>
<li>$w(x) = d(x, 0)$</li>
<li>$d(x,y) \geq 0$</li>
<li>$d(x, y ) = 0 \Leftrightarrow x = y$</li>
<li>$d(x, y) = d(y,x)$</li>
<li>$d(x,y) \leq d(x,z) + d(z,y)$</li>
</ul>
<p><strong>定理 8.13.</strong> $C$ 是 $d_{min} = 2n+1$ 的编码，则 $C$ 可以纠 $n$ 位错，可以检测 $2n$ 位错。</p>
<hr>
<h1 id="线性码（Linear-Codes）"><a href="#线性码（Linear-Codes）" class="headerlink" title="线性码（Linear Codes）"></a>线性码（Linear Codes）</h1><p><strong>群码</strong>（group code）：$\mathbb{Z}_2^n$ 的子群的编码。</p>
<p><strong>引理 8.17.</strong> $x,y$ 为 $n$ 位码字，则 $w(x  +y) = d(x,y)$。</p>
<p><strong>定理 8.18.</strong> 群码 $C$ 的 $d_{min}$ 是所有非零码字的最小的权重。</p>
<h2 id="线性码"><a href="#线性码" class="headerlink" title="线性码"></a>线性码</h2><p><strong>内积</strong>：</p>
<p> $\begin{aligned} \textbf{x}\cdot \textbf{y}  &amp;= \textbf{x}^t \textbf{y} \\ &amp;= \begin{pmatrix} x_1 &amp; x_2 &amp;\cdots &amp;x_n \end{pmatrix} \begin{pmatrix} y_1 \\ y_2 \\ \vdots \\ y_n  \end{pmatrix} \\ &amp;= x_1y_1 + x_2y_2 + \cdots + x_ny_n \end{aligned}$</p>
<p>记 $\mathbb{M}_{m\times n}(\mathbb{Z}_2)$ 为所有 $m$ 行 $n$ 列且元素属于 $\mathbb{Z}_2$ 的矩阵的集合。</p>
<p>$H \in \mathbb{M}_{m\times n}(\mathbb{Z}_2)$  的<strong>空域</strong>（null space我自己瞎起的名字）：$\{\textbf{x} \in \mathbb{Z}_2^n : H \textbf{x} = 0 \}$；记为 Null$(H)$。</p>
<p><strong>定理 8.21.</strong> $H \in \mathbb{M}_{m\times n}(\mathbb{Z}_2)$ 的 $null ~space$ 一定是群码。</p>
<p><strong>线性码</strong>：通过某个 $H \in \mathbb{M}_{m\times n}(\mathbb{Z}_2)$ 的 $null ~space$ 生成的编码。</p>
<hr>
<h1 id="奇偶校验和生成矩阵（Parity-Check-and-Generator-Matrices）"><a href="#奇偶校验和生成矩阵（Parity-Check-and-Generator-Matrices）" class="headerlink" title="奇偶校验和生成矩阵（Parity-Check and Generator Matrices）"></a>奇偶校验和生成矩阵（Parity-Check and Generator Matrices）</h1><p><strong>规范奇偶校验矩阵</strong>（canonical parity-check matrix）：$H \in \mathbb{M}_{m\times n}(\mathbb{Z}_2)$ 且 $n &gt; m$，且最后 $m$ 列形成的 $m \times m$ 子矩阵是单位阵 $I_m$，即 $H = \left( A | I_m \right)$。</p>
<p>每个规范奇偶校验阵 $H$ 都有一个 $n \times (n - m)$ 阶标准<strong>生成阵</strong>（standard generator matrix）: $G = \left( \dfrac{I_{n-m}}{A} \right)$。</p>
<p><strong>定理 8.25.</strong> $H$ 是一个规范奇偶校验阵，则 Null$(H)$ 包含了满足 前 $n-m$ 位随便取，但后 $m$ 位由 $H\textbf{x} = \textbf{0}$ 决定的 所有向量 $\textbf{x} \in \mathbb{Z}_2^n$。后 $m$ 位每个作为某个前 $n-m$ 位的偶校验位。所以，$H$ 可以给出一个 $(n, n-m)$ -分块码。</p>
<ul>
<li>前 $n-m$ 位叫<strong>信息位</strong>（information bit），后 $m$ 位叫校验位</li>
</ul>
<p><strong>定理 8.26.</strong>  $G$ 是一个 $n \times k$ 阶标准生成阵，则 $C = \{ \textbf{y} : G\textbf{x} = \textbf{y}, x \in \mathbb{Z}_2^n \}$ 是一个 $(n,k)$-分块码。</p>
<p><strong>引理 8.27.</strong> $H = (A | I_m)$ 是一个 $m \times n$ 规范奇偶校验阵, $G = \left( \dfrac{I_{n - m}}{A} \right)$ 是对应的 $n \times (n - m)$ 阶标准生成阵，则 $HG = 0$。</p>
<p><strong>定理8.28.</strong>  $H = (A | I_m)$ 是一个 $m \times n$ 规范奇偶校验阵, $G = \left( \dfrac{I_{n - m}}{A} \right)$ 是对应的 $n \times (n - m)$ 阶标准生成阵，$C$ 是由 $G$ 生成的编码。则 $\textbf{y} \in C \Leftrightarrow H\textbf{y} = 0$，也就是说，$C$ 是有规范奇偶校验矩阵的线性码。</p>
<p><strong>定理 8.31.</strong> $H$ 为一个 $m \times n$ 矩阵，$H$ 的空域是一个单检错码 当且仅当 $H$ 没有列是全零。（$e_i$ 不在空域中，$d_{min} &gt; 1$）</p>
<p><strong>定理 8.34.</strong> $H$ 为一个 $m \times n$ 矩阵，$H$ 的空域是一个单纠错码 当且仅当 $H$ 没有列是全零b并且没有两列是相同的。（$e_i + e_j$ 不在空域中，$d_{min} \geq 3$）</p>
<p>所以一个 $m \times n$ 的规范奇偶校验阵，要检一位错、纠一位错，除了 $\textbf{0}, \textbf{e_i}$，剩余 $2^m - (1 + m)$ 位为信息位。</p>
<hr>
<h1 id="高效解码"><a href="#高效解码" class="headerlink" title="高效解码"></a>高效解码</h1><p><strong>x</strong>的<strong>像</strong>（syndrome）：$H\textbf{x}$</p>
<p><strong>命题 8.36.</strong> 矩阵 $H$ 决定了一套线性码，$\textbf{x} = \textbf{c} + \textbf{e} $ 为接收到的$n$-位串，$\textbf{c}$ 为正确码字，$\textbf{e}$ 为错误，则 $H\textbf{x} = H\textbf{e}$。</p>
<ul>
<li>这个命题说明接受到的信息由错误决定而不是由正确码字决定。</li>
</ul>
<p><strong>定理 8.37.</strong> $H \in \mathbb{M}_{m\times n}(\mathbb{Z}_2)$ 并且假设 $H$ 的编码是一个单检错码，$\textbf{r}$ 是接收到的 $n$-位码，如果 $H\textbf{r} = \textbf{0}$，则没有错；否则，如果 $H\textbf{r} $ 等于 $H$ 的第 $i$ 列，则第 $i$ 位出错。</p>
<h2 id="陪集解码（Coset-Decoding）"><a href="#陪集解码（Coset-Decoding）" class="headerlink" title="陪集解码（Coset Decoding）"></a>陪集解码（Coset Decoding）</h2><p>把所有陪集表示（$\textbf{e} +     C$）列表列出来，查表解码纠错。</p>
<p>按最大似然，总是取权最小的出错 $\textbf{e}$ ，叫做 <strong>coset leader</strong>。</p>
]]></content>
      <categories>
        <category>problem-solving</category>
      </categories>
  </entry>
  <entry>
    <title>问题求解笔记-问题的形式化描述</title>
    <url>/2021/04/28/formalization/</url>
    <content><![CDATA[<p>庆祝终于脱离了常规算法的学习，进入了NP问题的坑。（</p>
<p>然后庆祝我们终于遇到了JH这本超级无敌晦涩难懂的教科书，真的是 <strong>太tmd难读了</strong>！！</p>
<p>在此附上助教对于该书的评价：</p>
<a id="more"></a>
<p><img data-src="chathistory.JPG" alt="最棒教科书" title="最棒教科书"></p>
<p>所以在整理笔记的同时，也是一个对内容汉化的过程，希望能有助于理解。。。<span class="github-emoji" alias="cold_sweat" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8">&#x1f630;</span></p>
<hr>
<h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><p><strong>字母表（alphabet）</strong>：一个非空有限集 $\Sigma$ 。</p>
<p><strong>符号（symbol）</strong>：字母表 $\Sigma$ 中的一个元素。</p>
<p><strong>字（word）</strong>：字母表中元素组成的一个序列。<strong>$\lambda$</strong>：空字。所有字的集合：$\Sigma^{\star}$</p>
<p><strong>字$w$长度$|w|$</strong>：该字中元素的个数。井$_a(w)$ ：字 $w$ 中符号 $a$ 出现的次数。</p>
<p>$\Sigma^n =  \{ x \in \Sigma | |x| = n\}$</p>
<p><strong>$u,v$ 的连接（concatenation）</strong>：$u,v$ 连起来，记作$uv$。</p>
<p><strong>前缀（prefix）、后缀（suffix）</strong>：前面/后面一截。</p>
<p><strong>子字（subword）</strong>：$z， w = uzv$。</p>
<p><strong>语言（language）</strong>：$L \subseteq \Sigma^{\star}$。它的补：$L^C = \Sigma^{\star} - L$。</p>
<p><strong>语言的连接</strong>：$L_1L_2 = L_1 \circ L_2 = \{ uv \in (\Sigma_1 \cup \Sigma_2)^{\star} | u \in L_1 ~ and ~ v \in L_2\}$。</p>
<p><strong>$\Sigma^{\star} $上的序</strong>：$\Sigma = \{s_1, s_2, \cdots, s_m \}$ 上有序 $s_1 &lt; s_2 &lt; \cdots &lt; s_m$，$u &lt; v$ 如果 $|u| &lt; |v|$ 或 $|u| = |v|, u = xs_iu’ , x = xs_jv’, i &lt; j$。先比长度，后比第一个不同的字符。</p>
<hr>
<h1 id="算法问题"><a href="#算法问题" class="headerlink" title="算法问题"></a>算法问题</h1><h2 id="判定问题（decision-problem）"><a href="#判定问题（decision-problem）" class="headerlink" title="判定问题（decision problem）"></a>判定问题（decision problem）</h2><p>$A$ 是一个算法， $x$ 是输入，$A(x)$ 标记为输出。</p>
<p>一个<strong>判定问题</strong>是指三元组 $(L, U, \Sigma), L \subseteq U \subseteq\Sigma^\star$，一般情况下 $U = \Sigma$，记为 $(L, \Sigma)$。算法 $A$ 解决这个问题是指对任意 $x \in U$ 有： $A(x) = 1, x\in L$ 并且 $A(x) = 0, x \in U - L$。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="素性检测（primality-testing）"><a href="#素性检测（primality-testing）" class="headerlink" title="素性检测（primality testing）"></a>素性检测（primality testing）</h3><script type="math/tex; mode=display">(Prim, \Sigma_{bool}), Prim = \{ w\in \{0, 1\} ^{star} | Number(w) \text{ is a prime}\}.</script><h3 id="多项式相等问题（EQ-POL）"><a href="#多项式相等问题（EQ-POL）" class="headerlink" title="多项式相等问题（EQ-POL）"></a>多项式相等问题（EQ-POL）</h3><h3 id="一次分支相等问题-EQ-1BP"><a href="#一次分支相等问题-EQ-1BP" class="headerlink" title="一次分支相等问题 (EQ-1BP)"></a>一次分支相等问题 (EQ-1BP)</h3><h3 id="满足性问题-（SAT）"><a href="#满足性问题-（SAT）" class="headerlink" title="满足性问题 （SAT）"></a>满足性问题 （SAT）</h3><script type="math/tex; mode=display">\text{SAT} = \{ w \in \Sigma^{\star}_{logic} | w \text{ is a code of a satisfable formula in CNF}\}.</script><h3 id="分团问题（CLIQUE）"><a href="#分团问题（CLIQUE）" class="headerlink" title="分团问题（CLIQUE）"></a>分团问题（CLIQUE）</h3><p>图中是否有大小为 $k$ 的团（clique）。</p>
<script type="math/tex; mode=display">CLIQUE = \{ x \# w \in \{ 0, 1, \#\}^{\star} | x\in \{0,1\}^{\star}, w \text{是一个有大小为 } Number(x) \text{ 的团的图}\}.</script><h3 id="覆盖问题（VCP）"><a href="#覆盖问题（VCP）" class="headerlink" title="覆盖问题（VCP）"></a>覆盖问题（VCP）</h3><p>图中是否有大小为 $k$ 的点覆盖。</p>
<h3 id="哈密顿回路问题（HC）"><a href="#哈密顿回路问题（HC）" class="headerlink" title="哈密顿回路问题（HC）"></a>哈密顿回路问题（HC）</h3><p>图中是否有哈密顿回路。</p>
<h2 id="优化问题（optimization-problem）"><a href="#优化问题（optimization-problem）" class="headerlink" title="优化问题（optimization problem）"></a>优化问题（optimization problem）</h2><h1 id="复杂度理论"><a href="#复杂度理论" class="headerlink" title="复杂度理论"></a>复杂度理论</h1><p>两个复杂度衡量：<strong>均匀消耗（uniform cost）</strong>，<strong>对数消耗（logarithmic cost）</strong></p>
<p>$Time_A(x), Space_A(x)$：算法 $A$ 对输入的 $x$ 的计算时间空间复杂度。</p>
<p><strong>定理 2.3.3.3.</strong> 对于一个判定问题 $(L , \Sigma_{bool})$，每个算法 $A$ 都存在另一个算法 $B$ 使得 $Time_B(n) = \log_2{(Time_A(n))}$</p>
<p><em>这个定理告诉我们对于 $L$ 不存在最优的算法，对 $L$ 的复杂度的定义也是没有意义的。所以人们通常不定义算法问题的复杂度儿研究问题复杂度的上下界（符号标记同TC）。</em></p>
<p><strong>图灵机</strong>是算法的直观概念的形式化，这意味着问题 $U$ 可以被算法解决当且仅当存在一个图灵机可以解决它。</p>
<p>对于每个递增函数 $f : \mathbb{N} \to \mathbb{R}^+$：</p>
<p>（1）存在一个判定问题，每个图灵机可以在 $\Omega(f(n))$ 的复杂度内解决它。</p>
<p>（2）也存在一个图灵机可以在 $O(f(n)\cdot \log{(f(n))})$  的复杂度内解决它。</p>
<p>这意味着判定问题有无穷级的难度。复杂度理论的主要内容就是<em>寻找一类可实际解决的问题的形式化说明</em> 和 <em>开发能够根据它们在这类问题中的关系进行分裂的方法</em>。</p>
<h2 id="形式化描述"><a href="#形式化描述" class="headerlink" title="形式化描述"></a>形式化描述</h2><p>对于一个图灵机（算法）$M$，$L(M)$ 是 $M$ 决定（decide）的语言。</p>
<p>能够在多项式时间内完成的复杂度问题类： </p>
<script type="math/tex; mode=display">P = \{L = L(M) |\exists c \in \mathbb{Z} , Time_M(n) \in O(n^c) \}</script><p>一个语言（判定问题）是<strong>可处理的（tractable）</strong> 当 $L \in P$，否则不可处理（intractable）。</p>
<p><strong>非确定性计算（nondeterministic computation）</strong>：引入随机数操作。</p>
<p>让 $M$ 为一个非确定性图灵机，定义 $M$ <strong>接受（accept）语言</strong> $L$，$L = L(M)$ 如果：</p>
<p>（1）对于任意 $x \in L$，$M$ 中存在至少一个接受（accept）$x$ 的计算。</p>
<p>（2）对于任意 $y \notin L$，$M$ 的所有计算拒绝（reject） $y$ 。</p>
<p>对于任意输入 $w$，$M$ 的时间复杂度 $Time_M(w)$ 是 $M$ 中的最短的接受的计算（accepting computation）。</p>
<p>通过非确定性算法能够在多项式时间内完成的判定问题类： </p>
<script type="math/tex; mode=display">NP = \{L(M) | M \text{是多项式时间的非确定性算法} \}</script><p>算法 <strong>B</strong> 对于输入 $x$ 的接受计算（accepting rejecting）可以看做对于是否 $x \in L$ 的证明。</p>
<p><em>这意味着确定性计算的复杂度是证明输出的正确性，非确定性计算的复杂度是对于一个给定的证明的确定的验证</em></p>
<p>$L \subseteq \Sigma^{\star}$ 是一个语言，一个输入为 $\Sigma^{\star} \times \{0, 1\}^{\star}$  的算法 <strong>A</strong> 称为 $L$ 的<strong>验证（verifier）</strong>，记作 $L = V(\textbf{A})$，如果 </p>
<script type="math/tex; mode=display">L = \{ w \in \Sigma^{\star} | A \text{ accept } (w,c) \text{，对于某个 } c \in \{0,1\}^{\star}\}</script><p>如果 $\textbf{A} \text{ accept } (w,c)$，我们称 $c$ 是事实（fact） $w \in L$ 的一个<strong>证明（proof/certificate）</strong>。</p>
<p><strong>A</strong> 是一个<strong>多项式时间验证（polynomial-time verifier）</strong>如果存在一个整数 $d$ ，使得对任意 $w\in L$，$Time_A(w, c) \in O(|w|^d)$ 对于某个 $w$ 的证明 $c$。</p>
<p>定义<strong>可多项式验证的语言类（class of polynomially verifiable languages）</strong>： </p>
<script type="math/tex; mode=display">VP = \{VP | A \text{ 是一个多项式验证}\}</script><p><strong>定理 2.3.3.9.</strong> $NP = VP$</p>
<p>$L_1 \subseteq \Sigma_1^{\star}, L_2 \subseteq \Sigma^{\star}_2$ 是两个语言，我们说 $L_1$ 对于 $L_2$ 是<strong>多项式时间可约的（polynomial-time reducible）</strong>，记作 $L_1 \leq_p L_2$，如果存在一个多项式时间算法 <strong>A</strong> 计算一个 $L_1$ 到 $L_2$ 的映射，即 </p>
<p><script type="math/tex">\forall x \in \Sigma_1^{\star}, x \in L_1 \Leftrightarrow A(x) \in L_2</script>。</p>
<p><strong>A</strong> 称作从 $L_1$ 到 $L_2$ 的多项式时间规约（reduction）。（说明 $L_2$ 至少和 $L_1$ 一样难。）</p>
<p>一个语言 $L$ 是 <strong>NP-hard</strong>，如果对于任意 $U \in NP, U \leq_p L$。</p>
<p>一个语言 $L$ 是 <strong>NP-complete</strong>，如果 $L \in NP$ 且 $L$ 是 NP-$hard$。</p>
]]></content>
      <categories>
        <category>problem-solving</category>
      </categories>
  </entry>
  <entry>
    <title>问题求解笔记-群同态基本定理与正规子群</title>
    <url>/2021/03/11/group-isomorphism-and-normal-subgroups/</url>
    <content><![CDATA[<hr>
<h1 id="同构-Isomorphisms"><a href="#同构-Isomorphisms" class="headerlink" title="同构 Isomorphisms"></a>同构 Isomorphisms</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>群$(G, \cdot )$ 和 $(H, \circ)$ <strong>同构（isomorphic）</strong>，如果存在一个双射 $\phi: G \rightarrow H$ 且满足</p>
<script type="math/tex; mode=display">\forall a, b \in G, \phi(a \cdot b) = \phi(a) \circ \phi(b)</script><p>记作 $G \cong H$。映射 $\phi$ 称为<strong>同构（isomorphism）</strong>。</p>
<a id="more"></a>
<p><strong>定理 9.6.</strong> $\phi: G \rightarrow H$ 是两个群上的同构，则有</p>
<ol>
<li>$\phi^{-1}: H \rightarrow G$ 也是一个同构。</li>
<li>$|G| = |H|$</li>
<li>$G$ 是阿贝尔群 $\Rightarrow$ $H$ 是阿贝尔群。</li>
<li>$G$ 是循环群 $\Rightarrow$ $H$ 是循环群。</li>
<li>$G$有一个 $n$ 阶子群 $\Rightarrow$ $H$ 有一个 $n$ 阶子群。</li>
</ol>
<p><strong>定理 9.7.</strong> 所有无限循环群和 $\mathbb{Z}$ 同构。</p>
<p><strong>定理 9.8.</strong> 所有 $n$ 阶循环群和 $\mathbb{Z}_{n}$ 同构。</p>
<p><strong>推论 9.9.</strong> $G$ 是一个 $p$ 阶群，$p$ 是一个质数，则 $G$ 同构于 $\mathbb{Z}_{p}$。</p>
<p><strong>定理 9.10.</strong> 群上的同构形成了所有群的类型的等价关系。</p>
<h3 id="凯利定理-Cayley’s-Theorem"><a href="#凯利定理-Cayley’s-Theorem" class="headerlink" title="凯利定理 Cayley’s Theorem"></a>凯利定理 Cayley’s Theorem</h3><p><strong>定理 9.12. Cayley</strong> 每个群都同构于一个置换群。</p>
<h2 id="外直积-External-Direct-Products"><a href="#外直积-External-Direct-Products" class="headerlink" title="外直积 External Direct Products"></a>外直积 External Direct Products</h2><p><strong>命题 9.13.</strong> $(G, \cdot), (H, \circ)$ 是两个群，$(g, h) \in G \times H, g \in G, h \in H$, 定义 $G \times H$ 上的二元运算：$(g_1, h_1)(g_2, h_2) = (g_1 \cdot g_2, h_1 \circ h_2)$，是一个群。</p>
<p>群 $G \times H$ 叫做 $G$ 和 $H$ 的<strong>外直积（external direct product）</strong>。</p>
<p><strong>定理 9.17.</strong> $(g, h) \in G \times H$，$g, h$ 都有有限的序数 $r, s$，则 $(g,h)$ 的序数是 $r$ 和 $s$ 的最小公倍数。</p>
<p><strong>定理 9.21.</strong> $\mathbb{Z}_m \times \mathbb{Z}_n \cong \mathbb{Z}_{mn} \Leftrightarrow gcd(m,n) = 1$</p>
<h2 id="内直积-Internal-Direct-Products"><a href="#内直积-Internal-Direct-Products" class="headerlink" title="内直积 Internal Direct Products"></a>内直积 Internal Direct Products</h2><p>如果群 $G$ 的两个子群 $H$ 和 $K$ 满足以下条件：</p>
<ul>
<li>$ G= HK = \{ hk: h \in H, k \in K \}$</li>
<li>$H \cap K = \{ e \}$</li>
<li>$\forall k \in K, \forall h \in H, hk = kh$</li>
</ul>
<p>则 $G$ 叫做 $H$ 和 $K$ 的<strong>直积（internal direct product）</strong>。</p>
<p><strong>定理 9.27.</strong> $G$ 是 $H$ 和 $K$ 的内直积 $\Rightarrow G \cong H \times K$。</p>
<hr>
<h1 id="正规子群和商群"><a href="#正规子群和商群" class="headerlink" title="正规子群和商群"></a>正规子群和商群</h1><h2 id="正规子群-Normal-Subgroups"><a href="#正规子群-Normal-Subgroups" class="headerlink" title="正规子群 Normal Subgroups"></a>正规子群 Normal Subgroups</h2><p>群 $G$ 的一个子群 $H$ 是<strong>正规的（normal）</strong>，如果 $\forall g \in G, gH = Hg$</p>
<p><strong>定理 10.3.</strong> $N$ 为群 $G$ 的一个子群，则以下命题等价：</p>
<ol>
<li>$N$ 是正规的。</li>
<li>$\forall g \in G, g N g^{-1} \subset N$</li>
<li>$\forall g \in G, g N g^{-1} = N$</li>
</ol>
<h2 id="商群-Factor-Groups"><a href="#商群-Factor-Groups" class="headerlink" title="商群 Factor Groups"></a>商群 Factor Groups</h2><p>$N$ 为群 $G$ 的一个子群，则 $N$ 的所有陪集形成了一个群 $G/N$，二元运算为 $(aN)(bN) = abN$。这个群叫做 $G$ 和 $N$ 的<strong>因子（factor）</strong>或<strong>商群（quotient group）</strong>。</p>
<p><strong>定理 10.4.</strong> $N$ 为群 $G$ 的一个子群，则 $N$ 的所有陪集形成了一个 $[G:N]$ 阶群 $G/N$。</p>
<h2 id="对换群的simplicity"><a href="#对换群的simplicity" class="headerlink" title="对换群的simplicity"></a>对换群的simplicity</h2><p>没有非平凡正规子群的群叫做<strong>（simple group）</strong>。</p>
<p><strong>引理 10.8.</strong> 对换群 $A_n$ 由三元环（3-cycles）生成。</p>
<p><strong>引理 10.9.</strong> $N$ 为群 $A_n$ 的一个子群。如果 $N$ 包含一个三元环，则 $N = A_n$。</p>
<p><strong>引理 10.10.</strong> 对于 $n \geq 5$，$A_n$ 的每个非平凡正规子群 $N$ 包含一个三元环。</p>
<p><strong>定理 10.11.</strong> 置换群 $A_n(n \geq 5)$ 是simple的。</p>
<hr>
<h1 id="同态"><a href="#同态" class="headerlink" title="同态"></a>同态</h1><h2 id="群同态-Group-Homomorphisms"><a href="#群同态-Group-Homomorphisms" class="headerlink" title="群同态 Group Homomorphisms"></a>群同态 Group Homomorphisms</h2><p>群 $(G, \cdot )$ 和 $(H, \circ)$ 间的<strong>同态（homomorphisms）</strong>是一个映射 $\phi: G \rightarrow H$ 且满足</p>
<script type="math/tex; mode=display">\forall a, b \in G, \phi(a \cdot b) = \phi(a) \circ \phi(b)</script><p>$\phi$ 在 $H$ 中的值域叫做<strong>同态像（homomorphic image）</strong>。</p>
<p><strong>命题 11.4.</strong> $\phi: G_1 \rightarrow G_2$ 是一个同态，则：</p>
<ol>
<li>$e$ 是 $G_1$ 的单位元 $\Rightarrow \phi(e) $ 是 $G_2$ 的单位元。</li>
<li>$\forall g \in G_1, \phi(g^{-1}) = [\phi(g)]^{-1}$</li>
<li>$H_1$ 是 $G_1$ 的子群 $\Rightarrow \phi(H_1)$ 是 $G_2$ 的子群。</li>
<li>$H_2$ 是 $G_2$ 的子群 $\Rightarrow \phi^{-1}(H_2) = \{ g \in G: \phi(g) \in H_2 \}$ 是 $G_1$ 的子群。进一步，$H_2$ 是 $G_2$ 的正规子群 $\Rightarrow \phi^{-1}(H_2)$ 是 $G_1$ 的正规子群。</li>
</ol>
<p>$\phi : G \Rightarrow H$ 是一个同态，$\phi^{-1}(\{ e \})$ 是 $G$ 的一个子集，叫做 $\phi$ 的<strong>核（kernel）</strong>，记作 $ker~\phi$。</p>
<p><strong>定理 11.5.</strong> $G \Rightarrow H$ 是一个同态，则 $\phi$ 的核是 $G$ 的一个正规子群。</p>
<h2 id="同构定理-Isomorphism-Theorems"><a href="#同构定理-Isomorphism-Theorems" class="headerlink" title="同构定理 Isomorphism Theorems"></a>同构定理 Isomorphism Theorems</h2><p>$H$ 为群 $G$ 的一个正规子群，定义<strong>自然同态（natural homomorphism）</strong> $\phi: G \rightarrow G / H, \phi(g) = gH$。</p>
<p><strong>定理 11.10. 同构第一定理</strong> $\psi: G \rightarrow H$ 是一个群同态，核为 $K = ker~\psi$ 是一个正规子群。$\phi:G \rightarrow G /K$ 为自然同态，则存在一个唯一同构 $\eta: G / K \rightarrow \psi(G)$，使得 $\psi = \eta \phi$。</p>
<p><strong>定理 11.12. 同构第二定理</strong> $H$ 是群 $G$ 的子群（不一定是正规的），$N$ 是 $G$ 的正规子群，则 $HN$ 是 $G$ 的子群，$H \cap N$ 是 $H$ 的正规子群，且</p>
<script type="math/tex; mode=display">H / (H \cap N) \cong (HN) / N</script><p><strong>定理 11.13 一致定理</strong> $N$ 是群 $G$ 的正规子群，则 $H \rightarrow H /N$ 是一个从 $G$ 的包含 $N$ 的子群的集合到 $G /N$ 的子群的集合的满射。进一步，从 $G$ 的包含 $N$ 的<strong>正规</strong>子群的集合到 $G /N$ 的子群的集合是双射。</p>
<p><strong>定理 11.14. 同构第三定理</strong> $G$ 是一个群，$N$ 和 $H$ 是正规子群且有 $N \subset H$，则 $G / H \cong \dfrac{GN}{HN}$.</p>
]]></content>
      <categories>
        <category>problem-solving</category>
      </categories>
  </entry>
  <entry>
    <title>问题求解笔记-群论初步</title>
    <url>/2021/02/26/group/</url>
    <content><![CDATA[<h1 id="群-Group"><a href="#群-Group" class="headerlink" title="群 Group"></a>群 Group</h1><h2 id="整数等价类-Integer-Equivalence"><a href="#整数等价类-Integer-Equivalence" class="headerlink" title="整数等价类 Integer Equivalence"></a>整数等价类 Integer Equivalence</h2><p>模运算下整数等价类的性质:</p>
<ol>
<li>加法乘法交换律</li>
<li>加法乘法结合律</li>
<li>加法(0)乘法(1)单位元</li>
<li>乘法分配律</li>
<li>任意元素存在加法逆元</li>
<li>$a$为非零整数，$gcd(a,n) = 1 \Leftrightarrow a$存在乘法逆元</li>
</ol>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>集合$G$上的一个<strong>二元运算(binary operation)</strong>或者一个<strong>合成律(law of composition)</strong>: 一个函数$f : G \times G \rightarrow G$, $f(a,b) = a \circ b$ or $ab$</li>
<li><strong>群</strong>$(G, \circ)$: 带有一个合成律的集合$G$, 且该合成律$(a, b) \rightarrowtail a \circ b$满足:<ul>
<li><strong>结合律(associative)</strong>: $\forall a, b, c \in G, (a \circ b) \circ c = a \circ (b \circ c)$</li>
<li><strong>单位元(identity element)</strong>: $\exists e \in G, \forall a \in G, a \circ e = e \circ a = a$</li>
<li><strong>逆元(inverse element)</strong>: $\forall a \in G, \exists a^{-1}\in G, a \circ a^{-1} = a^{-1}\circ a = e$</li>
</ul>
</li>
<li><strong>阿贝尔群(abelian)</strong>: 群$G$, $\forall  a, b \in G, a\circ b = b \circ a$</li>
<li><strong>凯利表(Cayley table)</strong>或<strong>交换群(commutative)</strong>: 通过加法或乘法来描述一个群的表格。</li>
<li><strong>可逆元素群(group of units)</strong>: 拥有逆元的元素组成的群</li>
<li>一般线性群(general linear group)</li>
<li>四元群(quaternion group)</li>
<li>群是有限的(finite)，或者说有有限序数(has finite order)，当它具有有限个元素，否则是无限的(infinite)或有无限序数(infinite order)</li>
</ul>
<h2 id="群的基本性质"><a href="#群的基本性质" class="headerlink" title="群的基本性质"></a>群的基本性质</h2><p><strong>命题3.17.</strong> 单位元唯一<br><strong>命题3.18.</strong> 逆元唯一<br><strong>命题3.19.</strong> $\forall a, b \in G, (ab)^{-1} = b^{-1}a^{-1}$</p>
<p><strong>命题3.20.</strong> $\forall a \in G, (a^{-1})^{-1} = a$</p>
<p><strong>命题3.21.</strong> $\forall a, b \in G,$ 方程$ax=b$和$xa=b$有唯一解</p>
<p><strong>命题3.22.</strong> $\forall a, b,bc \in G, ab=ac \Rightarrow b=c$, $ba=ca  \Rightarrow b= c$（左右约分）</p>
<p><strong>定理3.23.</strong> 基本指数运算都成立，$\forall g, h \in G$,</p>
<ol>
<li>$g^{m}g^{n} = g ^{m+n}$</li>
<li>$(g^{m})^{n} = g^{mn}$</li>
<li>$(gh)^{n} = (h^{-1}g^{-1})^{-n}$. $G$ is an abelian $\Rightarrow (gh)^{n} = g^{n}h^{n}$</li>
</ol>
<h2 id="子群-Subgroups"><a href="#子群-Subgroups" class="headerlink" title="子群 Subgroups"></a>子群 Subgroups</h2><ul>
<li>子群是父群的子集，也是个群</li>
<li><strong>平凡子群(trivival subgroup)</strong>: $H = \{ e \}$</li>
<li>真子群</li>
</ul>
<p><strong>定理3.30.</strong> $H$是$G$的子群$\Leftrightarrow$</p>
<ol>
<li>$G$的单位元$e \in H$</li>
<li>$\forall h_{1}, h_{2} \in H, h_{1}h_{2} \in H$</li>
<li>$\forall h \in H,  h^{-1} \in H$</li>
</ol>
<p><strong>定理3.31.</strong> $H \subset G$是$G$的子群$\Leftrightarrow H \neq \emptyset \wedge \forall g,h\in H, gh^{-1} \in H$</p>
<hr>
<h1 id="循环群-Cyclic-Groups"><a href="#循环群-Cyclic-Groups" class="headerlink" title="循环群 Cyclic Groups"></a>循环群 Cyclic Groups</h1><p><strong>定理4.3.</strong>  Let $G$ be a group and $a$ be any element in $G$. Then the set $\langle a\rangle =\{a^{k}:k\in\mathbb{Z}\}$ is a subgroup of $G$. Furthermore, $⟨a⟩$ is the smallest subgroup of $G$ that contains $a$.</p>
<ul>
<li><strong>循环子群(Cyclic Subgroups)</strong>: $\langle a \rangle$</li>
<li><strong>循环群</strong>: 包含了某个元素$a$，使得$G=⟨a⟩$.此时$⟨a⟩$是$G$的<strong>生成元(generator)</strong>.</li>
<li>$a$的<strong>序数(order)</strong>: 最小的正整数$n$, s.t. $a^{n} = e$, 记作$|a| = n$. 如果不存在，则为正无穷。</li>
</ul>
<p><strong>定理4.9.</strong> 所有循环群都是阿贝尔群。</p>
<h2 id="循环群的子群"><a href="#循环群的子群" class="headerlink" title="循环群的子群"></a>循环群的子群</h2><p><strong>定理4.10.</strong> 循环群的子群也都是循环群。<br><strong>推论4.11.</strong> $\mathbb{Z}$的所有子群就是$n\mathbb{Z}, n = 0,1,2,…$</p>
<p><strong>命题4.12.</strong> $G$为一个$n$阶循环群，$a$是$G$的一个生成元。则$a^{k} = e \Leftrightarrow n | k$（$k$是$n$的倍数）。</p>
<p><strong>定理4.13.</strong> $G$为一个$n$阶循环群，$a$是$G$的一个生成元。$b = a^{k} \Rightarrow b$的序数为$n / d, d = gcd(k,n)$。</p>
<p><strong>推论4.14.</strong> $\mathbb{Z}_{n}$的所有生成元$r$满足$1 \leq r &lt; n \wedge gcd(n,r) = 1$。</p>
<h2 id="复数乘法群-Multiplicative-Group-of-Complex-Numbers"><a href="#复数乘法群-Multiplicative-Group-of-Complex-Numbers" class="headerlink" title="复数乘法群  Multiplicative Group of Complex Numbers"></a>复数乘法群  Multiplicative Group of Complex Numbers</h2><p>复数知识</p>
<ul>
<li>$\cos \theta + i \sin \theta$ 记作 $cis\theta$<br><strong>定理2.22. DeMoivre</strong> $(r~cis\theta)^{n} = r^{n}~cis(n\theta)$</li>
</ul>
<h2 id="圆群-Circle-Group"><a href="#圆群-Circle-Group" class="headerlink" title="圆群 Circle Group"></a>圆群 Circle Group</h2><p>$\mathbb{T}: \{ z \in \mathbb{C}: |z| = 1 \}$<br><strong>命题4.24.</strong> 圆群是$\mathbb{C}^{*}$的一个子群。</p>
<p>满足$z^{n} = 1$的复数$z$称为$n$次<strong>单位根($n$-th roots of unity)</strong>。<br><strong>定理4.25.</strong> $z^{n} = 1 \Rightarrow z = cis(\dfrac{2k\pi}{n}), k = 0, 1, … , n-1$. $n$次单位根构成$\mathbb{T}$的一个圆子群。</p>
<h2 id="重复平方法-The-Method-of-Repeated-Squares"><a href="#重复平方法-The-Method-of-Repeated-Squares" class="headerlink" title="重复平方法 The Method of Repeated Squares"></a>重复平方法 The Method of Repeated Squares</h2><p>快速幂。</p>
]]></content>
      <categories>
        <category>problem-solving</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>问题求解笔记-启发式算法</title>
    <url>/2021/06/06/heuristics/</url>
    <content><![CDATA[<hr>
<h1 id="模拟退火算法（Simulated-Annealing）"><a href="#模拟退火算法（Simulated-Annealing）" class="headerlink" title="模拟退火算法（Simulated Annealing）"></a>模拟退火算法（Simulated Annealing）</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>$U = (\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal)$ 是一个优化问题，对任意的 $x \in L_I$，$\mathcal{M}(x)$ 的一个<strong>邻域（Neighborhood）</strong>是一个映射 $f_x: \mathcal{M}(x) \to Pot(\mathcal{M(x)})$ 满足：</p>
<ul>
<li><p>$\forall \alpha \in \mathcal{M}(x), \alpha \in f_x(\alpha)$</p>
</li>
<li><p>如果 $\exists \alpha \in \mathcal{M}(x), \beta\in f_x(\alpha)$，则 $\alpha \in f_x(\beta)$</p>
</li>
<li><p>对任意的 $\alpha, \beta \in \mathcal{M}(x)$，所在一个正整数 $k$ 和 $\gamma_1, …, \gamma_k \in \mathcal{M}(x)$，使得 </p>
<p>$\gamma_1 \in f_x(\alpha), \gamma_{i  +1 } \in f_x(\gamma_i), i = 1, … k-1$ 且 $\beta \in f_x(\gamma_k)$​</p>
</li>
</ul>
</li>
<li>$LSS(Neigh)$</li>
</ul>
<a id="more"></a>
<p>模拟退火算法是从一个物理退火模型（Metropolos Algorithm）类比启发启发得到的，和 $LSS$ 的区别是有概率允许状态向恶化的方向转化，来防止局部最优解。</p>
<p>一些概念的类比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">物理退火</th>
<th style="text-align:center">模拟退火</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">系统状态</td>
<td style="text-align:center">可行解集合</td>
</tr>
<tr>
<td style="text-align:center">状态能量</td>
<td style="text-align:center">可行解的代价</td>
</tr>
<tr>
<td style="text-align:center">扰动机制</td>
<td style="text-align:center">从邻居的随机选择</td>
</tr>
<tr>
<td style="text-align:center">一个最优状态</td>
<td style="text-align:center">一个最优可行解</td>
</tr>
<tr>
<td style="text-align:center">温度</td>
<td style="text-align:center">控制参数</td>
</tr>
</tbody>
</table>
</div>
<p>所以模拟退火其实就是建立在类比 Metropolos Algorithm上，得到的一个局部搜索算法。</p>
<p>对于一个优化问题的固定的邻域，模拟退火可以被描述为：</p>
<p><img data-src="SA.png" alt title="模拟退火算法"></p>
<h2 id="理论和经验"><a href="#理论和经验" class="headerlink" title="理论和经验"></a>理论和经验</h2><p><strong>定理 6.2.2.1.</strong>  $U$ 是一个最小化问题且让 $Neigh$ 是 $U$ 的邻域，对于输入 $x$ 模拟退火算法的渐进收敛（asymptotic convergence）被保证如果以下两个条件被满足：</p>
<ul>
<li>每个 $\mathcal{M}(x)$ 的可行解是可到达的，从每个其他的 $\mathcal{M}(x)$ 的可行解。（邻域的定义条件III）</li>
<li>初始条件 $T$ 至少是最深的局部最小值。</li>
</ul>
<p><em>渐进收敛意味着随着迭代次数的增长，到达全局最优的概率趋向于1</em>。</p>
<p><em>就是说模拟退火算法会 find itself at a  global optimum an increasing percentage of the time as time grows.</em>（我也没读懂）</p>
<p>一般还有要求：</p>
<ul>
<li>邻域的对称性（邻域定义的条件II）</li>
<li><p>邻域的均匀性，$\forall \alpha, \beta \in \mathcal{M}(x),|Neigh_x (\alpha)| = |Neigh_x(\beta)|$</p>
</li>
<li><p>通过特定的 <em>cool schedules</em>，$T$ 增长缓慢</p>
</li>
</ul>
<p>很遗憾在限定的迭代次数内，模拟退火并不能确保可行解的高质量，一般需要解空间的平方大小的次数的迭代。所以相比运行模拟退火到确保一个正确的近似解，还不如直接搜索全空间。。。</p>
<p>模拟退火的收敛率是和迭代次数成对数关系。</p>
<p>应该尽可能地避免以下结构的邻域：</p>
<ul>
<li>毛刺结构</li>
<li>深沟</li>
<li>大高原</li>
</ul>
<p><em>因为模拟退火第一部分是在高温下完成的，使得所有恶化方向都有可能，所以可以视为对初始解的随机搜索。然后当 $T$ 很小，大的恶化基本上是不可能的。</em></p>
<p>如果谈到 cool schedules，以下的参数一定要确定：</p>
<ul>
<li>初始温度 $T$</li>
<li>温度缩减函数 $f(T, t)$</li>
<li>终止条件</li>
</ul>
<h3 id="初始温度的选择"><a href="#初始温度的选择" class="headerlink" title="初始温度的选择"></a>初始温度的选择</h3><p>需要很大。</p>
<p>一种方法是取任意两个相邻解的最大差值，比较难算，所以只要高效地找到一个估计值（上界）就足够了。</p>
<p>另一种实用的方法是，从任意 $T$ 值开始，在选择了初始情况 $\alpha$ 的邻居 $\beta$ 后，以一种使 $\beta$ 以靠近1的概率被接受的方式增加 $T$。进行若干次迭代，可以得到一个合理的初值 $T$。<em>可以看作物理类比的加热过程</em></p>
<h3 id="选择温度缩减函数（Temperature-Reduction-Function）"><a href="#选择温度缩减函数（Temperature-Reduction-Function）" class="headerlink" title="选择温度缩减函数（Temperature Reduction Function）"></a>选择温度缩减函数（Temperature Reduction Function）</h3><p>一个一般的方式是 $T$ 乘以一个系数 $0.8\leq r \leq 0.99$，工作常数 $d$ 步得到 $T := r \cdot T$。</p>
<p>也就是缩减 $k$ 次得到的温度 $T_k$ 为 $r_k\cdot T$。</p>
<p>另一个选择是 $T_k := \dfrac{T}{\log_2{(k  +2)}}$，常数 $k$ 一般为邻域的大小。</p>
<h3 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a>终止条件</h3><p>一个方法是终止条件独立于 $T$，当解的代价（cost）不变时终止。</p>
<p>另一种是设一个常数 $term$，当 $T \leq term$ 时终止。</p>
<h3 id="一般性质"><a href="#一般性质" class="headerlink" title="一般性质"></a>一般性质</h3><ul>
<li>模拟退火算法能够得到一个高质量解，但需要大开销的运算。</li>
<li>最终解的质量和初始解的选择关系不大。</li>
<li>重要的两个参数是缩减率和邻域，有必要做一定的工作来调参。</li>
<li>平均复杂度和最差复杂度很接近。</li>
<li>在相同的邻域下，模拟退火一般比局部搜索或多源局部搜索表现得更好。</li>
</ul>
<h3 id="一些问题的应用"><a href="#一些问题的应用" class="headerlink" title="一些问题的应用"></a>一些问题的应用</h3><ul>
<li>图位置算法（最大最小割）一般表现较好。</li>
<li>工程问题（VLSI）是最好的算法。</li>
<li>TSP等表现不太好。</li>
</ul>
<h2 id="随机禁忌？搜索（Randomized-Tabu-Search）"><a href="#随机禁忌？搜索（Randomized-Tabu-Search）" class="headerlink" title="随机禁忌？搜索（Randomized Tabu Search）"></a>随机禁忌？搜索（Randomized Tabu Search）</h2><p>思想就是：保存一些之前的可行解的信息，并在决定下一个可行解时用上。</p>
<p><img data-src="RTS.png" alt></p>
<hr>
<h1 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>遗传算法是从个体种群的进化优化启发而来，进化可以被概括为以下过程：</p>
<ol>
<li>一个个体可以用一个字符串来表示（DNA序列）。</li>
<li><strong>交配（crossover）</strong>，也就是交换两个父母字符串的一部分，获得子串。</li>
<li>存在一个<strong>适应值（fitness value）</strong>，适应值高的串以更高的概率被选择。</li>
<li><strong>变异（mutation）</strong>，随机变一位。</li>
<li>去世。</li>
</ol>
<p>一些概念的类比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">种群遗传进化</th>
<th style="text-align:center">遗传算法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">一个个体</td>
<td style="text-align:center">一个可行解</td>
</tr>
<tr>
<td style="text-align:center">一个基因</td>
<td style="text-align:center">解中的一位</td>
</tr>
<tr>
<td style="text-align:center">适应值</td>
<td style="text-align:center">代价函数</td>
</tr>
<tr>
<td style="text-align:center">种群</td>
<td style="text-align:center">可行解的一个子集</td>
</tr>
<tr>
<td style="text-align:center">变异</td>
<td style="text-align:center">随机局部转化</td>
</tr>
</tbody>
</table>
</div>
<p>遗传算法和模拟退火有两个区别，一是用一组可行解而不是一个可行解，二是不能被视为纯粹的局部搜索。</p>
<p>在一个合适的可行解表示下，遗传算法可以被描述为：</p>
<p><img data-src="GAS.png" alt title="GAS"></p>
<p>如果不考虑交配，只考虑变异，那么遗传算法和模拟退火很类似。</p>
<ul>
<li><p>$U = (\Sigma_I, \Sigma_O, L, L_I, \mathcal{M}, cost, goal)$ 是一个优化问题，对一个给定大小为 $n$ 的输入 $x \in L_I$，每个 $\alpha \in \{0, 1\}^n$ 代表 $x$ 的一个可行解，即 $\mathcal{M}(x) = \{0, 1\}^n$。$\mathcal{M}(x)$ 的一个 <strong>模式（schema）</strong> 是一个向量 $s = (s_1, s_2, …, s_n) \in \{0, 1, \star\}^n$。$s$ 的一组可行解是</p>
<script type="math/tex; mode=display">
Schema(s_1, s_2, ..., s_n) = \{\gamma_1, \gamma_2, ..., \gamma_n \in \mathcal{x} | \gamma_i = s_i , s_i \in \{0,1\} ~or~ \gamma_i \in \{0,1\}, s_i = \star \}</script></li>
<li><p>模式 $s$ 的长度 $length(s)$ 是第一位到最后一个非 $\star$ 位的距离。阶 $order(s)$ 是非 $\star$ 的位数。</p>
</li>
<li><p>在一个种群 $P$ 中的<strong>适应度（Fitness）</strong> 是 $Schema(s)$ 的可行解的平均适应度：</p>
<script type="math/tex; mode=display">
Fitness(s, P) = \dfrac{1}{|Schema(s) \cap P|} \cdot \sum\limits_{\gamma \in Schema(s) \cap P} cost(\gamma).</script></li>
<li><p>在一个种群 $P$ 中的<strong>适应率（Fitness ratio）</strong>是：</p>
<script type="math/tex; mode=display">
Fit\text{-}ratio = \dfrac{Fitness(s, P)}{\frac{1}{|P|} \sum_{\beta \in P}cost(\beta)}</script></li>
<li><p>$Aver\text{-}Fit(P) = \frac{1}{|P|}\sum_{\beta\in P} cost(\beta)$ 叫做种群 $P$ 的平均适应度。</p>
</li>
</ul>
<p><em>其实模式（schema）就是在可行解的表达中固定一些基因的值，其中 $\star$ 位就是自由变量，所以 $|Schema(s)|$ 就是$\star$的数量的2次幂。一个有比种群平均适应度高很多的适应度的模式就是一个很好的基因，应该被在进化中被遗传。</em></p>
<ul>
<li>$P_0$ 为初始种群，$P_t$ 为第 $t$ 次迭代基因算法后的种群，$X_{t + 1}(s)$ 是一个随机变量，是从 $P_t$ 中随机选择的父母且在 $Schema(s)$ 的数量。选择 $\alpha \in P_t$ 的概率是：$Pr_{par}(\alpha) = \dfrac{cost(\alpha)}{\sum_{\beta\in P_t} cost(\beta)} = \dfrac{cost(\alpha)}{|P_t| \cdot Aver\text{-}Fit(P_t)}$</li>
</ul>
<p><strong>引理 6.3.1.2.</strong> 对任意的 $t \in \mathbb{N}$ 和任意模式 $s$，$E[X_{t + 1}(s)] = Fit\text{-}ratio(s, P_t) \cdot |P_t \cap Schema(s)|$。</p>
<p><strong>引理 6.3.1.3.</strong> 对任意的模式 $s$ 和任意 $t = 1, 2,…$，</p>
<script type="math/tex; mode=display">
E[Y_{t+1}(s)] \geq \dfrac{|P_t|}{2} \cdot \left[2 \cdot \left( \dfrac{E[X_{t+1}(s)]}{|P_t|}\right)^2 + 2 \cdot \dfrac{n - length(s)}{n} \cdot\dfrac{E[X_{t+1}(s)]}{|P_t|} \cdot \left( 1 - \dfrac{E[X_{t+1}(s)]}{|P_t|} \right) \right].</script><p><strong>引理 6.3.1.4.</strong> 对任意的模式 $s$ 和任意 $t = 1, 2,…$，</p>
<script type="math/tex; mode=display">
E[Y_{t + 1}(s)] \geq \dfrac{n - length(s)}{n} \cdot E[X_{t+1}(s)].</script><p><strong>引理 6.3.1.5.</strong> 对任意的模式 $s$ 和任意 $t = 1, 2,…$，</p>
<script type="math/tex; mode=display">
E[Z_{t + 1}(s)] \geq (1 - pr_{m})^{order(s)} \cdot E[Y_{t+1}(s)] \geq (1 - order(s) \cdot pr_m) \cdot E[Y_{t+1}(s)].</script><p><strong>定理 6.3.1.6.（GAS的模式定理）</strong></p>
<p>对任意的模式 $s$ 和任意 $t = 1, 2,…$，在第 $(t+1)-st$ 的种群 $P_{t+1}$ 中的为模式 $Schema(s)$ 的个体的数量的期望为</p>
<script type="math/tex; mode=display">
E[Z_{t+1}] \geq Fit\text{-}ratio(s, P_t) \cdot \dfrac{n-  length(s)}{n} \cdot (1 - order(s)\cdot pr_m) \cdot |P_t \cdot Schema(s)|.</script><h2 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h2><h3 id="种群大小"><a href="#种群大小" class="headerlink" title="种群大小"></a>种群大小</h3><ul>
<li>小种群容易导致局部最优解。</li>
<li>反之大种群更容易到达全局最优解。</li>
</ul>
<h3 id="初始种群的选择"><a href="#初始种群的选择" class="headerlink" title="初始种群的选择"></a>初始种群的选择</h3><ul>
<li>常用的是随机选择。</li>
<li>将一些预处理的高质量可行解引入初始种群可以加快收敛速度。</li>
<li>最好是结合起来，部分随机部分高适应度。</li>
</ul>
<h3 id="适应度评估和父母选择机制"><a href="#适应度评估和父母选择机制" class="headerlink" title="适应度评估和父母选择机制"></a>适应度评估和父母选择机制</h3><ul>
<li>适应度 $\alpha$ 直接用 $cost(\alpha)$，然后按概率分布 $p(\alpha) = \dfrac{cost(\alpha)}{\sum_{\beta \in P} cost(\beta)}$ 选择父母。</li>
<li>当 $max(P)$ 和 $min(P)$ 很接近时，$P$ 几乎均匀分布，一般选择 $fitness(\alpha) = cost(\alpha) - C, C &lt; min(P)$</li>
<li>选择 $k / 2$ 个最好的个体，再随机选择 $k/2$ 个个体进行配偶。</li>
<li>通过<strong>秩（ranking）</strong>来随机选择，按代价排序后 $cost(\alpha_1) \leq cost(\alpha_2) \leq …\leq cost(\alpha_n)$，然后分配概率 $prob(\alpha_i) = \dfrac{2i}{n(n+1)}$ 选择父母。</li>
</ul>
<h3 id="个体和交配的形式表示"><a href="#个体和交配的形式表示" class="headerlink" title="个体和交配的形式表示"></a>个体和交配的形式表示</h3><ul>
<li>允许不代表任何可行解的表示存在，但可能降低复杂度。</li>
<li>不直接在父母的表示上进行交配，而是通过一些特点参数，寻找子代的交叉混合属性。</li>
<li>在上面所有的情况，交配都是只考虑一个交配位置的简单交配，可以与更复杂的交配的概念结合起来。</li>
</ul>
<h3 id="变异的可能性"><a href="#变异的可能性" class="headerlink" title="变异的可能性"></a>变异的可能性</h3><ul>
<li>通常改变一位基因的概率调整为小于 $\frac{1}{100}$。</li>
<li>有时候取 $\frac{1}{n}$ 或 $\frac{1}{k^{0.93}\sqrt{n}}$，$n$ 是基因数量，$k$ 是种群规模。</li>
<li>有时候在计算过程中动态改变概率，如果种群中个体过于相似，增加突变概率，防止局部最优。</li>
</ul>
<h3 id="新种群的选择机制"><a href="#新种群的选择机制" class="headerlink" title="新种群的选择机制"></a>新种群的选择机制</h3><ul>
<li>子代完全取代父代，<strong>en block</strong> 策略。</li>
<li>从子代和父代中同时选择，需要调整子代对父代的偏爱程度。一种常见的是从父代中挑选一些适应度最高的，种群中绝大多数是子代。</li>
<li>在选择了新的种群后，可以立即开始交配生产新种群，也可以提高种群平均适应度，可以选择小邻域进行局部搜索或模拟退火，得到一个局部最优的个体。</li>
</ul>
<h3 id="终止标准"><a href="#终止标准" class="headerlink" title="终止标准"></a>终止标准</h3><ul>
<li>在一开始确定时间限制。</li>
<li>测量种群的平均适应度和个体之间的差异，如果平均适应度没有本质改变，或个体非常相似，遗传可以停止。</li>
</ul>
]]></content>
      <categories>
        <category>problem-solving</category>
      </categories>
  </entry>
  <entry>
    <title>问题求解笔记-数论算法</title>
    <url>/2021/04/08/number-theory-algorithms/</url>
    <content><![CDATA[<hr>
<h1 id="数论算法"><a href="#数论算法" class="headerlink" title="数论算法"></a>数论算法</h1><p><strong>定理 31.2.</strong> 如果任意整数 $a$ 和 $b$ 都不为 $0$，则 $gcd(a, b)$ 是 $a$ 与 $b$ 的线性组合集 $\{ ax + by : x, y \in \mathbb{Z} \}$ 中的最小正元素。</p>
<p><strong>推论 31.3.</strong> 任意整数 $a$ 和 $b$，$d | a \wedge d|b \Rightarrow d | gcd(a,b)$。</p>
<p><strong>推论 31.4</strong> 对所有整数 $a,b$ 及任意非负整数 $n$，有 <script type="math/tex">gcd(an,bn) = n~gcd(a,b)</script>。</p>
<p><strong>推论 31.5.</strong> 对所有正整数 $a,b,n$，$n | ab \wedge gcd(a, n) = 1 \Rightarrow n | b$。</p>
<p><strong>定理 31.6.</strong> 对所有正整数 $a,b,p$，$gcd(a, p ) = 1 \wedge gcd(b, p) = 1 \Rightarrow gcd(ab, p) = 1$。</p>
<p><strong>定理 31.7.</strong> 对所有的素数 $p$ 和所有整数 $a,b$， $p | ab \Rightarrow p |a \vee p | b$。</p>
<p><strong>定理 31.8.</strong>（唯一因子分解定理）合数 $a$ 的素因子分解是唯一的。</p>
<a id="more"></a>
<p><strong>定理 31.9</strong> $\forall a, b, gcd(a, b) = gcd(b, a ~mod ~b)$.</p>
<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p><img data-src="euclid.png" alt="ECULID" title="eculid"></p>
<p>（这个图片为什么这么大。。。就这样吧反正我也不会调）</p>
<h3 id="欧几里得算法的运行时间"><a href="#欧几里得算法的运行时间" class="headerlink" title="欧几里得算法的运行时间"></a>欧几里得算法的运行时间</h3><p><strong>引理 31.10.</strong> 如果 $a &gt; b \geq 1$ 并且 ECULID$(a,b)$ 执行了 $k \geq 1$ 次递归调用，则 $a \geq F_{k+2}, b \geq F_{k+1}$。</p>
<p><strong>引理 31.11.</strong>（Lame引理）对任意整数 $k \geq 1$，如果 $a &gt; b \geq 1$，且 $b &lt; F_{k+1}$，则 EUCLID$(a,b)$ 的递归调用次数少于 $k$ 次。</p>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p><img data-src="extgcd.png" alt="EXT-ECULID" title="ext-eculid"></p>
<ul>
<li>递归调用次数为 $O(\lg{b})$。</li>
</ul>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><ul>
<li><p><strong>欧拉函数</strong>：<script type="math/tex">\phi(n) = n \prod\limits_{p\text{是素数且}p|n} (1 - \dfrac{1}{p})</script></p>
</li>
<li><p>$\phi(n) &gt; \dfrac{n}{e^\gamma \ln{\ln{n}} + \dfrac{3}{\ln{\ln{n}}}}$</p>
</li>
</ul>
<p>  <strong>定理31.15.</strong> （拉格朗日定理）：如果 $(S, \oplus)$ 是一个有限群，$(S’, \oplus )$ 是 $(S,\oplus)$ 的一个子群，则 $|S’|$ 是 $|S|$ 的一个约数。（我觉得比TJ上讲的通俗易懂得多。。。）</p>
<p>  <strong>推论 31.16.</strong> 如果 $S’$ 是有限群 $S$ 的真子群，则 $|S’ | \leq |S| / 2$。</p>
<p><strong>定理 31.17.</strong> 对任意有限群 $(S, \oplus)$ 和任意 $a \in S$，一个元素的阶等于它所生成的子群的规模，即 $ord(a) = |\langle a \rangle|$。</p>
<p><strong>推论 31.18.</strong> 序列 $a^{(1)}, a^{(2)}, …$是周期序列，其周期为 $t = ord(a)$，即 $a^{(i)} = ^{(j)} \Leftrightarrow i \equiv j~ (\text{mod }t)$。</p>
<p><strong>推论 31.19.</strong> 如果 $(S, \oplus)$ 是具有单位元的有限群，则对所有 $a \in S$，$a^{(|S|)} = e$。</p>
<h2 id="求解模线性方程"><a href="#求解模线性方程" class="headerlink" title="求解模线性方程"></a>求解模线性方程</h2><p><strong>定理 31.20.</strong> 对任意正整数 $a$ 和 $n$，如果 $d = gcd(a,n)$，则在 $\mathbb{Z}_n$ 中，$\langle a \rangle = \langle d \rangle = \{ 0, d, 2d, \cdots , ((n/d) - 1)d \}$。因此，$|\langle a \rangle| = n /d$。</p>
<p><strong>推论 31.21.</strong> $d | b \Leftrightarrow \text{方程} ax \equiv b (\text{mod } n)$ 对 $x$ 有解，$d  =gcd(a,n)$。 </p>
<p><strong>推论 31.22</strong> 方程 $ax \equiv b (\text{mod } n)$ 要么模 $n$ 下有 $d$ 个不同的解，要么无解。</p>
<p><strong>定理 31.23.</strong> 假设对某些整数 $x’, y’$ 有 $d = ax’ + ny’$。如果 $d | b$，则方程 $ax \equiv b(\text{mod } n)$ 有一个解的值为 $x_0$，<script type="math/tex">x_0 = x'(b / d) \mod n</script></p>
<p><strong>定理 31.24.</strong> 假设方程 $ax \equiv b(\text{mod } n)$ 有解，且 $x_0$ 是该方程的任意一个解。则该方程对模 $n$ 恰有 $d = gcd(a,n)$ 个解为 $x_i = x_0 + i(n /d), i =0, 1, \cdots, d- 1$。</p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p><strong>定理 31.27.</strong>（中国剩余定理） 令 $n = n_1 n_2\cdots n_k$，其中因子 $n_i$ 两两互质。考虑以下对应关系：</p>
<script type="math/tex; mode=display">a \leftrightarrow (a_1, a_2, \cdots, a_k)</script><p>这里 $a \in \mathbb{Z}_n, a_i \in \mathbb{Z}_{n_i}$，且对 $i = 1, 2, \cdots, k$，</p>
<script type="math/tex; mode=display">a_i =  a \mod n_i</script><p>则通过在合适的系统中对每个坐标位置独立地执行操作，对 $\mathbb{Z}_n$ 中元素所执行地运算可以等价地作用于对应的 $k$ 元组。</p>
<p><strong>推论 31.28.</strong> 如果 $n_1, n_2, \cdots, n_k$ 两两互质，则关于未知量 $x$ 地联立方程组 <script type="math/tex">x \equiv a_i (\text{mod } n_i), i = 1, 2, \cdots,k</script> 对模 $n$ 有唯一解。</p>
<p><strong>推论 31.29.</strong> 如果 $n_1, n_2, \cdots, n_k$ 两两互质，则对所有整数 $x$ 和 $a$，$x \equiv a(\text{mod } n_i), i = 1, 2, \cdots, k \Leftrightarrow x \equiv a (\text{mod } n)$。</p>
<h2 id="元素的幂"><a href="#元素的幂" class="headerlink" title="元素的幂"></a>元素的幂</h2><p><strong>定理 31.32.</strong> 对所有地素数 $p &gt; 2$ 和所有的正整数 $e$，使得 $\mathbb{Z}_n^*$ 是循环群的 $n &gt; 1$ 的值为 $2, 4, p^e, p^{2e}$。</p>
<p>如果 $g$ 是 $\mathbb{Z}_{b}^{\star}$ 的一个原根且 $a$ 是 $\mathbb{Z}_{b}^{\star}$ 中的任意元素，则存在一个 $z$，使得 $g^{z} \equiv a(\text{mod } n)$ 。这个 $z$ 称为对模 $n$ 到基 $g$ 上的一个<strong>离散对数</strong>。</p>
<p><strong>定理 31.33.</strong>（离散对数定理）如果 $g$ 是 $\mathbb{Z}_b^*$ 的一个原根，$x \equiv y(\text{mod } \phi(n)) \Leftrightarrow g^x \equiv g^y (\text{mod } \phi(n))$。</p>
<p><strong>定理 31.34.</strong> $p$ 是一个奇素数且 $e &gt; 1 \Rightarrow x^2 \equiv 1(\text{mod } p^e)$ 仅有两个解 $x =1, x= -1$。</p>
<h2 id="反复平方法"><a href="#反复平方法" class="headerlink" title="反复平方法"></a>反复平方法</h2><p>快速幂</p>
]]></content>
      <categories>
        <category>problem-solving</category>
      </categories>
  </entry>
  <entry>
    <title>问题求解笔记-数论基础</title>
    <url>/2021/03/20/number-theory/</url>
    <content><![CDATA[<h1 id="数学归纳法-Mathematical-Induction"><a href="#数学归纳法-Mathematical-Induction" class="headerlink" title="数学归纳法 Mathematical Induction"></a>数学归纳法 Mathematical Induction</h1><p>没啥好讲的。<br><strong>第一第二数学归纳法</strong><br><strong>良序公理</strong><br><a id="more"></a></p>
<h1 id="辗转相除法-Division-Algorithm"><a href="#辗转相除法-Division-Algorithm" class="headerlink" title="辗转相除法 Division Algorithm"></a>辗转相除法 Division Algorithm</h1><p><strong>定理 2.9.</strong> $a$ 和 $b$ 为整数，$b &gt; 0$，则存在<strong>唯一整数</strong> $q$ 和 $r$，使得</p>
<script type="math/tex; mode=display">a = bq + r</script><p>其中 $0 \leq r &lt; b$。</p>
<p>$a$ 整除 $b$ 记作 $a | b$。<br>最大公约数、互质等概念略。</p>
<p><strong>定理 2.10.</strong> $a$ 和 $b$ 为非零整数，则存在整数 $r，s$，使得</p>
<script type="math/tex; mode=display">gcd(a,b) = ar + bs</script><p>进一步，$a,b$的最大公约数是唯一的。</p>
<p><strong>推论 2.11.</strong> $a,b$ 互质，则存在整数 $r,s$，使得 $ar + bs = 1$。（可证反之也成立）</p>
<h2 id="欧几里得算法-Euclidean-Algorithm"><a href="#欧几里得算法-Euclidean-Algorithm" class="headerlink" title="欧几里得算法 Euclidean Algorithm"></a>欧几里得算法 Euclidean Algorithm</h2><h2 id="质数-Prime-Number"><a href="#质数-Prime-Number" class="headerlink" title="质数 Prime Number"></a>质数 Prime Number</h2><p><strong>定理 2.14.</strong> 存在无穷多质数。（证明挺重要的）</p>
<p><strong>定理 2.15. 算数基本定理</strong> $n$ 为整数，则 $n$ 可以唯一表示为多个素数的乘积。</p>
<script type="math/tex; mode=display">n = p_1 p_2 ... p_k</script><hr>
<h1 id="乘法逆元和最大公约数"><a href="#乘法逆元和最大公约数" class="headerlink" title="乘法逆元和最大公约数"></a>乘法逆元和最大公约数</h1><p><strong>乘法逆元 Multipllication Inverse</strong>: $a’ \in \mathbb{Z}_n, a \in \mathbb{Z}_n, a \cdot_n a’ = a$，则称 $a’$ 是 $a$ 在 $\mathbb{Z}_n$ 中的乘法逆元。</p>
<p><strong>引理 2.5.</strong> 解模方程： 如果 $a$ 在 $\mathbb{Z}_n$ 中有逆元 $a’$，则对任意 $b \in \mathbb{Z}_n$，方程</p>
<script type="math/tex; mode=display">a \cdot_n x = b</script><p>有唯一解 $x = a’ \cdot_n b$。</p>
<p><strong>推论 2.6.</strong> 如果存在 $b \in \mathbb{Z}_n$，方程</p>
<script type="math/tex; mode=display">a \cdot_n x = b</script><p>无解，则 $a$ 没有逆元。</p>
<p><strong>定理 2.7.</strong> 若有逆元则唯一。</p>
<p><strong>引理 2.8.</strong> 方程</p>
<script type="math/tex; mode=display">a \cdot_n x = 1</script><p>有解当且仅当存在整数 $x,y$，使得</p>
<script type="math/tex; mode=display">ax + ny = 1</script><p><strong>定理 2.9.</strong> $a \in \mathbb{Z}_n$ 有逆元 $\Leftrightarrow$ 存在整数 $x，y$，使得 $ax + ny = 1$。</p>
<p><strong>推论 2.10.</strong> $a \in \mathbb{Z}_n$ 且存在整数 $x，y$，使得 $ax + ny = 1$，则 $a$ 的逆元为 $x$ (mod $n$)。</p>
<p><strong>引理 2.11.</strong> 给定 $a,n$，如果存在整数 $x，y$，使得 $ax + ny = 1$，则 $a,n$ 互质，即 $gcd(a,n) = 1$。</p>
<p><strong>定理 2.12.</strong> 同最上面一条。</p>
<p><strong>引理 2.13.</strong> $j,k,q,r$ 是正整数，满足 $k = j q + r$，则</p>
<script type="math/tex; mode=display">gcd(j,k) = gcd(r, j)</script><p><strong>定理 2.15.</strong> $gcd(j,k)  = 1 \Leftrightarrow \exists x,y, jx + ky = 1$.</p>
<p><strong>推论 2.16.</strong> $a\in \mathbb{Z}_n$ 在 $\mathbb{Z}_n$ 中有逆元 $\Leftarrow gcd(a,n) = 1$。</p>
<p><strong>推论 2.17.</strong> 对任意质数 $p$，每个非零整数 $a \in \mathbb{Z}_p$ 都有逆元。</p>
]]></content>
      <categories>
        <category>problem-solving</category>
      </categories>
  </entry>
  <entry>
    <title>pandas</title>
    <url>/2021/03/06/pandas/</url>
    <content><![CDATA[<p>本文主要是对于python库<code>pandas</code>的学习使用笔记。<br>参考网站：<br><a href="https://pandas.pydata.org/">pandas官方网站</a><br><a href="https://www.pypandas.cn/">一个不错的pandas中文网站</a><br><a id="more"></a></p>
<h1 id="pandas是啥"><a href="#pandas是啥" class="headerlink" title="pandas是啥"></a>pandas是啥</h1><p>这个库主要是用来干啥的？<br>Python在数据处理和准备方面一直做得很好，pandas主要用来做数据分析和建模而不必切换到更特定于领域的语言，如R。<br>方便数据的读写，智能数据对齐和丢失数据的综合处理，数据集的灵活调整和旋转，基于智能标签的切片、花式索引和大型数据集的子集。。。</p>
<hr>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>pandas最重要的就是它的数据结构：<br><a href="https://pandas.pydata.org/pandas-docs/stable/reference/series.html">Series</a>: 带标签的一维同构数组<br><a href="https://pandas.pydata.org/pandas-docs/stable/reference/frame.html">DataFrame</a>: 带标签的，大小可变的，二维异构表格</p>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><figure class="highlight python"><figcaption><span>创建Series</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pd.Series(data, index=index) <span class="comment">#index: 索引名字</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>data</code>是多维数组时，<code>index</code>长度必须与<code>data</code>长度一致，默认<code>[0, 1, ..., len(data)-1]</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pd.Series(np.random.randn(<span class="number">5</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s </span><br><span class="line">a    <span class="number">0.469112</span></span><br><span class="line">b   -<span class="number">0.282863</span></span><br><span class="line">c   -<span class="number">1.509059</span></span><br><span class="line">d   -<span class="number">1.135632</span></span><br><span class="line">e    <span class="number">1.212112</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.index</span><br><span class="line">Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt; s.dtype</span><br><span class="line">dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><code>data</code>是字典时，直接key-value，按插入顺序排列</li>
<li><p><code>data</code>是标量，按索引重复</p>
</li>
<li><p><code>Series</code>操作与<code>ndarray</code>类似，支持大多数 NumPy 函数，还支持索引切片。</p>
</li>
</ul>
<h3 id="支持矢量操作"><a href="#支持矢量操作" class="headerlink" title="支持矢量操作"></a>支持矢量操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.exp(s)</span><br><span class="line">a         <span class="number">1.598575</span></span><br><span class="line">b         <span class="number">0.753623</span></span><br><span class="line">c         <span class="number">0.221118</span></span><br><span class="line">d         <span class="number">0.321219</span></span><br><span class="line">e    <span class="number">162754.791419</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<ul>
<li>Series 和多维数组的主要区别在于， Series 之间的操作会自动基于标签对齐数据。因此，不用顾及执行计算操作的 Series 是否有相同的标签。</li>
<li>操作未对齐索引的 Series， 其计算结果是所有涉及索引的并集。如果在 Series 里找不到标签，运算结果标记为<code>NaN</code>，即缺失值。</li>
</ul>
<h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><p><code>Series</code> 支持 <code>name</code>属性，就是这列数据的名称。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.Series(np.random.randn(<span class="number">5</span>), name=<span class="string">&#x27;something&#x27;</span>)</span><br><span class="line">s2 = s.rename(<span class="string">&quot;different&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p><code>DataFrame</code> 是由多种类型的列构成的二维标签数据结构，类似于 Excel 、SQL 表，或 Series 对象构成的字典。</p>
<h3 id="用-Series-字典生成-DataFrame"><a href="#用-Series-字典生成-DataFrame" class="headerlink" title="用 Series 字典生成 DataFrame"></a>用 Series 字典生成 DataFrame</h3><ul>
<li>生成的索引是每个 Series 索引的并集。先把嵌套字典转换为 Series。如果没有指定列，DataFrame 的列就是字典键的有序列表。</li>
<li>index 和 columns 属性分别用于访问行、列标签：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;one&#x27;</span>: pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), <span class="string">&#x27;two&#x27;</span>: pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.DataFrame(d)</span><br><span class="line">   one  two</span><br><span class="line">a  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="number">2.0</span></span><br><span class="line">c  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">d  NaN  <span class="number">4.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.DataFrame(d, index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">   one  two</span><br><span class="line">d  NaN  <span class="number">4.0</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="number">2.0</span></span><br><span class="line">a  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.DataFrame(d, index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], columns=[<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]) </span><br><span class="line">   two three</span><br><span class="line">d  <span class="number">4.0</span>   NaN</span><br><span class="line">b  <span class="number">2.0</span>   NaN</span><br><span class="line">a  <span class="number">1.0</span>   NaN</span><br></pre></td></tr></table></figure>
<h3 id="备选构建器"><a href="#备选构建器" class="headerlink" title="备选构建器"></a>备选构建器</h3><ul>
<li>DataFrame.from_dict</li>
<li>DataFrame.from_records</li>
</ul>
<h3 id="提取、添加、删除列"><a href="#提取、添加、删除列" class="headerlink" title="提取、添加、删除列"></a>提取、添加、删除列</h3><p>就像带索引的Series字典<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> df[<span class="string">&#x27;one&#x27;</span>]</span><br><span class="line">a    <span class="number">1.0</span></span><br><span class="line">b    <span class="number">2.0</span></span><br><span class="line">c    <span class="number">3.0</span></span><br><span class="line">d    NaN</span><br><span class="line">Name: one, dtype: float64</span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">&#x27;three&#x27;</span>] = df[<span class="string">&#x27;one&#x27;</span>] * df[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">&#x27;flag&#x27;</span>] = df[<span class="string">&#x27;one&#x27;</span>] &gt; <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   one  two  three   flag</span><br><span class="line">a  <span class="number">1.0</span>  <span class="number">1.0</span>    <span class="number">1.0</span>  <span class="literal">False</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="number">2.0</span>    <span class="number">4.0</span>  <span class="literal">False</span></span><br><span class="line">c  <span class="number">3.0</span>  <span class="number">3.0</span>    <span class="number">9.0</span>   <span class="literal">True</span></span><br><span class="line">d  NaN  <span class="number">4.0</span>    NaN  <span class="literal">False</span></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> df[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>three = df.pop(<span class="string">&#x27;three&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   one   flag</span><br><span class="line">a  <span class="number">1.0</span>  <span class="literal">False</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="literal">False</span></span><br><span class="line">c  <span class="number">3.0</span>   <span class="literal">True</span></span><br><span class="line">d  NaN  <span class="literal">False</span></span><br><span class="line"><span class="comment"># 标量重复</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">&#x27;foo&#x27;</span>] = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   one   flag  foo</span><br><span class="line">a  <span class="number">1.0</span>  <span class="literal">False</span>  bar</span><br><span class="line">b  <span class="number">2.0</span>  <span class="literal">False</span>  bar</span><br><span class="line">c  <span class="number">3.0</span>   <span class="literal">True</span>  bar</span><br><span class="line">d  NaN  <span class="literal">False</span>  bar</span><br><span class="line"><span class="comment"># 插入与 DataFrame 索引不同的 Series 时，以 DataFrame 的索引为准</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">&#x27;one_trunc&#x27;</span>] = df[<span class="string">&#x27;one&#x27;</span>][:<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   one   flag  foo  one_trunc</span><br><span class="line">a  <span class="number">1.0</span>  <span class="literal">False</span>  bar        <span class="number">1.0</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="literal">False</span>  bar        <span class="number">2.0</span></span><br><span class="line">c  <span class="number">3.0</span>   <span class="literal">True</span>  bar        NaN</span><br><span class="line">d  NaN  <span class="literal">False</span>  bar        NaN</span><br><span class="line"><span class="comment"># 可以插入原生多维数组，但长度必须与 DataFrame 索引长度一致。默认在 DataFrame 尾部插入列。insert 函数可以指定插入列的位置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.insert(<span class="number">1</span>, <span class="string">&#x27;bar&#x27;</span>, df[<span class="string">&#x27;one&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   one  bar   flag  foo  one_trunc</span><br><span class="line">a  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="literal">False</span>  bar        <span class="number">1.0</span></span><br><span class="line">b  <span class="number">2.0</span>  <span class="number">2.0</span>  <span class="literal">False</span>  bar        <span class="number">2.0</span></span><br><span class="line">c  <span class="number">3.0</span>  <span class="number">3.0</span>   <span class="literal">True</span>  bar        NaN</span><br><span class="line">d  NaN  NaN  <span class="literal">False</span>  bar        NaN</span><br></pre></td></tr></table></figure></p>
<h3 id="asign分配新链"><a href="#asign分配新链" class="headerlink" title="asign分配新链"></a>asign分配新链</h3><ul>
<li><code>assign</code> 返回的都是副本数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dfa = pd.DataFrame(&#123;<span class="string">&quot;A&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&quot;B&quot;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dfa.assign(C=dfa[<span class="string">&#x27;A&#x27;</span>] + dfa[<span class="string">&#x27;B&#x27;</span>], D=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;A&#x27;</span>] + x[<span class="string">&#x27;C&#x27;</span>])</span><br><span class="line">   A  B  C   D</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">7</span>   <span class="number">9</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span>  <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="索引，选择"><a href="#索引，选择" class="headerlink" title="索引，选择"></a>索引，选择</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">句法</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">选择列</td>
<td style="text-align:left">df[col]</td>
<td style="text-align:left">Series</td>
</tr>
<tr>
<td style="text-align:left">用标签选择行</td>
<td style="text-align:left">df.loc[label]</td>
<td style="text-align:left">Series</td>
</tr>
<tr>
<td style="text-align:left">用整数位置选择行</td>
<td style="text-align:left">df.iloc[loc]</td>
<td style="text-align:left">Series</td>
</tr>
<tr>
<td style="text-align:left">行切片</td>
<td style="text-align:left">df[5:10]</td>
<td style="text-align:left">DataFrame</td>
</tr>
<tr>
<td style="text-align:left">用布尔向量选择行</td>
<td style="text-align:left">df[bool_vec]</td>
<td style="text-align:left">DataFrame</td>
</tr>
</tbody>
</table>
</div>
<p>选择行返回 Series，索引是 DataFrame 的列：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">one              <span class="number">2</span></span><br><span class="line">bar              <span class="number">2</span></span><br><span class="line">flag         <span class="literal">False</span></span><br><span class="line">foo            bar</span><br><span class="line">one_trunc        <span class="number">2</span></span><br><span class="line">Name: b, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数据对齐和运算"><a href="#数据对齐和运算" class="headerlink" title="数据对齐和运算"></a>数据对齐和运算</h3><ul>
<li>DataFrame 对象可以自动对齐列与索引（行标签）的数据，生成的结果是列和行标签的并集。</li>
<li>DataFrame 和 Series 之间执行操作时，默认操作是在 DataFrame 的列上对齐 Series 的索引，按行执行广播操作。</li>
<li>时间序列是特例，DataFrame 索引包含日期时，按列广播</li>
</ul>
<h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><p><code>df[:5].T</code></p>
<h3 id="DataFrame-应用-Numpy-函数"><a href="#DataFrame-应用-Numpy-函数" class="headerlink" title="DataFrame 应用 Numpy 函数"></a>DataFrame 应用 Numpy 函数</h3><ul>
<li>Series 与 DataFrame 可使用 log、exp、sqrt 等多种元素级 NumPy 通用函数（ufunc）</li>
<li>DataFrame 不是多维数组的替代品，它的索引语义和数据模型与多维数组都不同。</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>问题求解笔记-置换群和拉格朗日定理</title>
    <url>/2021/03/07/permutation-group-and-lagrange-theorem/</url>
    <content><![CDATA[<h1 id="置换群-Permutation-Groups"><a href="#置换群-Permutation-Groups" class="headerlink" title="置换群 Permutation Groups"></a>置换群 Permutation Groups</h1><h2 id="定义和记号"><a href="#定义和记号" class="headerlink" title="定义和记号"></a>定义和记号</h2><ul>
<li>集合$S$上的一个<strong>置换（permutation）</strong>：one-to-one and onto map: $\pi: S \rightarrow S$</li>
</ul>
<a id="more"></a>
<ul>
<li>集合$X$的所有置换构成一个群$S_{X}$，$X = \{ 1, 2, …, n\}$时记为$S_{n}$。该群叫<strong>对称群（Symmetric Group）</strong>。</li>
</ul>
<p><strong>定理5.1.</strong> $n$个letter的对成群$S_{n}$是一个有$n!$个元素的群，其二元运算为复合（composition）。</p>
<ul>
<li>$S_{n}$的子群称为<strong>置换群（Permutation Group）</strong></li>
</ul>
<h3 id="轮换（Cycle-Notation）"><a href="#轮换（Cycle-Notation）" class="headerlink" title="轮换（Cycle Notation）"></a>轮换（Cycle Notation）</h3><ul>
<li>一个置换$\sigma \in S_{X}$是一个长度为$k$的<strong>轮换（cycle）</strong>，如果存在$a_{1}, a_{2}, …, a_{k}\in X$，使得<br>$\sigma(a_{1}) = a_{2}, \sigma(a_{2}) = a_{3}, … ,\sigma(a_{k}) = a_{1}$。</li>
</ul>
<p><strong>命题5.8.</strong> $\sigma$ 和 $\tau$ 是$S_{X}$中两个不相交轮换 $\Rightarrow \sigma \tau = \tau \sigma$</p>
<p><strong>定理5.9.</strong> $S_{n}$中的每个置换都可以写成不相交轮换的乘积。</p>
<h3 id="对换（Transposition）"><a href="#对换（Transposition）" class="headerlink" title="对换（Transposition）"></a>对换（Transposition）</h3><p><strong>对换（Transposition）</strong>：长度为2的轮换。<br>$(a_{1}, a_{2}, …, a_{3}) = (a_{1}, a_{n})(a_{1}, a_{n-1})…(a_{1}a_{2})$</p>
<p><strong>命题5.12.</strong> 每个元素个数大于2的有限集合的置换都可以写成对换的乘积。</p>
<p><strong>引理5.14.</strong> 如果恒等变换被写成$id = \tau_{1} \tau_{2} … \tau_{r} \Rightarrow r$是偶数。</p>
<p><strong>定理5.15.</strong>  如果一个排列能被写成偶数个置换乘积的形式，那么另一个与之等价的排列也一定拥有偶数项置换乘积。奇数同理。<br>据此定理可以将排列分为奇偶两类</p>
<h3 id="交替群-Alternating-Groups"><a href="#交替群-Alternating-Groups" class="headerlink" title="交替群 Alternating Groups"></a>交替群 Alternating Groups</h3><p><strong>交替群</strong>：$S_{n}$的所有偶置换$A_{n}$。</p>
<p><strong>定理5.16.</strong> $A_{n}$ 是 $S_{n}$ 的子群</p>
<p><strong>命题5.17.</strong> 奇偶置换的个数相等，都是$n!/2$，即$A_{n}$的大小。</p>
<h2 id="二面体群-Dihedral-Groups"><a href="#二面体群-Dihedral-Groups" class="headerlink" title="二面体群 Dihedral Groups"></a>二面体群 Dihedral Groups</h2><p><strong>n阶二面体群</strong>：正n边形的刚性运动，记为$D_{n}$</p>
<p><strong>定理5.20.</strong> $D_{n}$ 是 $S_{n}$ 的大小为$2n$的子群。</p>
<p><strong>定理5.23.</strong> 包含所有旋转$r$ 和对称 $s$ 的乘积的群 $D_{n}$，满足以下两个关系：</p>
<script type="math/tex; mode=display">r^{n} = 1</script><script type="math/tex; mode=display">s^{2} = 1</script><script type="math/tex; mode=display">srs = r^{-1}</script><h2 id="立方体移动群-The-Motion-Group-of-a-Cube"><a href="#立方体移动群-The-Motion-Group-of-a-Cube" class="headerlink" title="立方体移动群 The Motion Group of a Cube"></a>立方体移动群 The Motion Group of a Cube</h2><p><strong>命题5.27.</strong> 立方体移动群有24个元素。<br><strong>定理5.28.</strong> 立方体移动群是$S_{4}$。</p>
<hr>
<h1 id="陪集和拉格朗日定理"><a href="#陪集和拉格朗日定理" class="headerlink" title="陪集和拉格朗日定理"></a>陪集和拉格朗日定理</h1><h2 id="陪集-Cosets"><a href="#陪集-Cosets" class="headerlink" title="陪集 Cosets"></a>陪集 Cosets</h2><p>$G$ 是一个群，$H$ 是 $G$ 的子群。集合$H$的代表元为$g\in G$的<strong>左陪集（Left Coset）</strong>：$gH = \{ gh: h \in H \}$。右陪集类似。</p>
<p><strong>引理6.3.</strong> $H$ 为群 $G$ 的子群，$g_{1}, g_{2} \in G$，则以下条件等价：</p>
<ol>
<li>$g_{1}H = g_{2} H$</li>
<li>$Hg_{1}^{-1} = Hg_{2}^{-1}$</li>
<li>$g_{1}H \subset g_{2}H$</li>
<li>$g_{2} \in g_{1}H$</li>
<li>$g_{1}^{-1}g_{2} \in H$</li>
</ol>
<p><strong>定理6.4.</strong> $H$ 为群 $G$ 的子群。$H$ 的所有左陪集分割(partition)了 $G$,即 $G$ 是 $H$ 的左陪集的disjoint union. (右陪集同理)</p>
<p>$H$ 的<strong>index</strong>：$G$ 中 $H$ 的左陪集的个数，记为$[G:H]$。</p>
<p><strong>定理6.8.</strong> $H$ 的左陪集和右陪集个数相等。</p>
<h2 id="拉格朗日定理-Lagrange’s-Theorem"><a href="#拉格朗日定理-Lagrange’s-Theorem" class="headerlink" title="拉格朗日定理 Lagrange’s Theorem"></a>拉格朗日定理 Lagrange’s Theorem</h2><p><strong>命题6.9.</strong> map $\phi: H \rightarrow gH$是双射。所以 $H$ 和 $gH$ 的元素个数相同。</p>
<p><strong>定理6.10. Lagrange</strong> $G$ 的元素个数是子群 $H$ 的元素个数的整数倍，为 $H$ 的所有左陪集的个数。即$|G| / |H| = [G:H]$。</p>
<p><strong>推论6.11.</strong> $G$ 的所有元素$g$的order是$|G|$的约数。</p>
<p><strong>推论6.12.</strong> $|G|= p$，$p$为质数，则 $G$ 是循环群且除了单位元$e$的元素都是生成元。</p>
<p><strong>推论6.13.</strong> $K \subset H \subset G \Rightarrow [G:K] = [G:H][H:K]$.</p>
<ul>
<li>拉格朗日定理的逆命题不一定成立。</li>
</ul>
<p><strong>定理6.16.</strong> $S_{n}$ 中的两个轮换 $\tau$ 和 $\mu$ 有相同的长度 $\Leftrightarrow \exists \sigma \in S_{n}, \mu =\sigma \tau \sigma^{-1}$. （相似？）</p>
<h2 id="费马与欧拉定理-Fermat’s-and-Euler’s-Theorem"><a href="#费马与欧拉定理-Fermat’s-and-Euler’s-Theorem" class="headerlink" title="费马与欧拉定理 Fermat’s and Euler’s Theorem"></a>费马与欧拉定理 Fermat’s and Euler’s Theorem</h2><p><strong>欧拉函数</strong>$\phi$-<em>function</em>: map $\phi: \mathbb{N} \rightarrow \mathbb{N}$, 与$n$互质的整数$m(1\leq m &lt;n)$的个数，$\phi(1) = 1$。</p>
<p><strong>定理6.17.</strong> $U(n)$ 为 $\mathbb{Z}_{n}$ 的units的群，则 $|U(n)| = \phi(n)$。</p>
<p><strong>定理6.18. Euler’s Theorem</strong> 正整数$a, n$，$n &gt; 0 \wedge gcd(a,n) = 1 \Rightarrow a^{\phi(n)} \equiv 1$ (mod $n$)。</p>
<p><strong>定理6.19. Fermat’s Little Theorem</strong> $p$为质数，$p \nmid a \Rightarrow a^{p-1} \equiv 1$ (mod $p$)。<br>$\forall b \in \mathbb{Z}, b^{p} \equiv b$ (mod $p$).</p>
]]></content>
      <categories>
        <category>problem-solving</category>
      </categories>
  </entry>
  <entry>
    <title>问题求解笔记-随机算法</title>
    <url>/2021/05/26/randomized-algorithm/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>我们至今仍然不知道任何NP难问题的随机多项式算法。</p>
<p>我们只知道一些问题，满足：</p>
<ul>
<li>有高效的多项式随机算法</li>
<li>没有已知的多项式时间确定算法</li>
<li>不知道它是否属于 $P$</li>
</ul>
<p>随机算法和近似算法结合的合理性在于，算法输出错误结果的概率甚至小于确定性算法长时间运行下硬件出错的概率。</p>
<a id="more"></a>
<hr>
<h1 id="随机算法的分类"><a href="#随机算法的分类" class="headerlink" title="随机算法的分类"></a>随机算法的分类</h1><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>我们可以把随机算法就看成是在运行中需要随机数的算法，并且后续运行需要这些随机数。</p>
<ul>
<li>$S_{A,x} = \{ C | C \text{ 是 }A \text{ 在 }x \text{ 上的一个随机计算}\}$。（样本空间）</li>
<li><p>$Prob $ 是 $S_{A,x} $ 的概率分布。</p>
</li>
<li><p>$Random_A(x)$ 是 $A $ 在 $x$ 上运行中的最大随机数位数。</p>
</li>
<li>$Random_A(n) = \max\{Random_A(x) | x \text{ 是大小为 } n \text{ 的输入}\}$。</li>
</ul>
<p>复杂度的衡量是重要的因为：</p>
<ul>
<li>生成伪随机数需要开销，一般和位数成正比</li>
<li>“去随机化”</li>
</ul>
<p>算法 $A$ 对于输入 $x$ 输出 $y$ 的概率 $Prob(A(x) = y)$ 是所有 $C$ 输出 $y$ 的 $Prob_{A , x}(C) $ 的和。随机算法的目标就是让输出正确的 $y$ 的 $Prob(A(x) = y)$ 尽可能大。</p>
<ul>
<li><p>$Time(C) $ 是 $C$ 的运行时间，则 $A $ 对于输入 $x$ 的期望时间复杂度是： </p>
<script type="math/tex; mode=display">Exp\text{-}Time_A(x) = E[Time] = \sum\limits_{C}Prob_{A,x}(C) \cdot Time(C)</script></li>
<li><p>$Exp\text{-}Time_A(n) = \max\{Random_A(x) | x \text{ 是大小为 } n \text{ 的输入}\}$。</p>
</li>
<li><p>有时我们也考虑最坏情况复杂度： $Time_A(x) = \max\{Time(C) | C \text{ 是 }A \text{ 在 }  x \text{ 上的运行} \}$。</p>
</li>
<li><p>$Time_A(n) = \max\{Time_A(x) | x \text{ 是大小为 } n \text{ 的输入} \}$。</p>
</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="拉斯维加斯算法（Las-Vegas-Algorithms）"><a href="#拉斯维加斯算法（Las-Vegas-Algorithms）" class="headerlink" title="拉斯维加斯算法（Las Vegas Algorithms）"></a>拉斯维加斯算法（Las Vegas Algorithms）</h3><p>定义一个算法 $A$ 是问题 $F$ 的拉斯维加斯算法：</p>
<ol>
<li><p>对于任意的输入 $x$，$Prob(A(x) = F(x)) = 1$，$F(x)$ 是问题 $F$ 对 $x$ 的解。</p>
<ul>
<li>这样 $A$ 的复杂度一般被认为是 $Exp\text{-}Time_A(n)$。</li>
</ul>
</li>
<li><p>我们允许输出 “?”（不能按时解决问题）。对任意的输入 $x$，$Prob(A(x) = F(x)) \geq \dfrac{1}{2}$ 且 </p>
<p><script type="math/tex">Prob(A(x)= ?)=  1 - Prob(A(x) = F(x)) \leq \dfrac{1}{2}</script>。</p>
<ul>
<li>这样 $A$ 的复杂度一般被认为是 $Time_A(n)$，因为一般需要运行到 $Time_A(x)$ 才能判断“?”。</li>
</ul>
</li>
</ol>
<h3 id="单错蒙特卡罗算法（One-Sided-Error-Monte-Carlo-Algorithm）"><a href="#单错蒙特卡罗算法（One-Sided-Error-Monte-Carlo-Algorithm）" class="headerlink" title="单错蒙特卡罗算法（One-Sided-Error Monte Carlo Algorithm）"></a>单错蒙特卡罗算法（One-Sided-Error Monte Carlo Algorithm）</h3><p>只对判定问题有用。</p>
<p>算法 $A$ 是语言 $L$ 的单错蒙特卡罗算法当：</p>
<ol>
<li>对任意的 $x \in L$，$Prob(A(x) = 1 ) \geq 1/2$；</li>
<li>对任意的 $x \notin L$，$Prob(A(x)  = 0) = 1$。</li>
</ol>
<p>所以单错蒙特卡罗算法不会误判错误的输入，但有小概率误判正确的输入，只有单方向错。</p>
<h3 id="双错蒙特卡算法（Two-Sided-Error-Monte-Carlo-Algorithm）"><a href="#双错蒙特卡算法（Two-Sided-Error-Monte-Carlo-Algorithm）" class="headerlink" title="双错蒙特卡算法（Two-Sided-Error Monte Carlo Algorithm）"></a>双错蒙特卡算法（Two-Sided-Error Monte Carlo Algorithm）</h3><p>$F$ 是一个计算问题，一个随机算法 $A$ 是双错蒙特卡算法当：</p>
<ul>
<li>存在一个实数 $0 &lt; \varepsilon \leq 1/2$，使得对任意的输入 $x$ ， $Prob(A(x) = F(x)) \geq \dfrac{1}{2}  + \varepsilon$。</li>
<li>让算法跑 $t$ 次，取出现次数至少是 $\lceil t / 2 \rceil$ 的结果，正确的概率很大。</li>
</ul>
<h3 id="无界错蒙特卡罗算法（Unbounded-Error-Monte-Carlo-Algorithm）"><a href="#无界错蒙特卡罗算法（Unbounded-Error-Monte-Carlo-Algorithm）" class="headerlink" title="无界错蒙特卡罗算法（Unbounded-Error Monte Carlo Algorithm）"></a>无界错蒙特卡罗算法（Unbounded-Error Monte Carlo Algorithm）</h3><p>$F$ 是一个计算问题，一个随机算法 $A$ 是无界错蒙特卡算法当：</p>
<ul>
<li>对任意输入 $x$，$Prob(A(x) = F(x)) &gt; \dfrac{1}{2}$。</li>
<li>缺点在于 $Prob(A(x) = F(x))$ 和 $\dfrac{1}{2}$ 可能趋近于 $0$ 当输入很大时。</li>
<li>为了从无界错蒙特卡罗算法获得一个随机算法满足 $Prob(A_{k(|n|)} (x) = F(x)) \geq 1 - \delta, 0 \leq \delta \leq \dfrac{1}{2}$，我们必须接受 $Time_{A_{k(n)}}(n) = O(2^{2Random_A(n)} \cdot Time_A(n))$</li>
</ul>
<h3 id="随机优化算法（Randomized-Optimization-Algorithm）"><a href="#随机优化算法（Randomized-Optimization-Algorithm）" class="headerlink" title="随机优化算法（Randomized Optimization Algorithm）"></a>随机优化算法（Randomized Optimization Algorithm）</h3><p>我们一般不考虑正确解出现的频率，而直接取最优解。所以一个 $k$ 轮算法中最优解的概率是</p>
<script type="math/tex; mode=display">
Prob(A_k(x) \in Output_U(x)) = 1 - [Prob(A(x) \notin Output_U(x))]^k,</script><p>其中 $A_k$ 指运行 $k$ 次随机优化算法 $A$。</p>
<ul>
<li>若 $Prob(A(x) \notin Output_U(x)) \leq \varepsilon, \varepsilon &lt; 1$，则 $A$ 和单错蒙特卡罗效率差不多。</li>
<li>若 $Prob(A(x) \in Output_U(x)) \geq 1 / p(|x|)$，$p$ 为多项式，则 $A$ 的效率也很可观。</li>
</ul>
<h2 id="随机近似算法"><a href="#随机近似算法" class="headerlink" title="随机近似算法"></a>随机近似算法</h2><ul>
<li>$U = (\Sigma_I, \Sigma_O, L, L_I,\mathcal{M}, cost, goal)$ 是一个优化问题，对任意的实数 $\delta &gt; 1$，一个随机算法 $A$ 叫做 $U$ 的<strong>随机$\delta$-近似算法</strong>，当满足对任意的 $x\in L_I$：<ul>
<li>$Prob(A(x) \in \mathcal{M}(x)) = 1$，</li>
<li>$Prob(R_A(x) \leq \delta)\geq 1/ 2$。</li>
</ul>
</li>
<li>对任意的函数 $f :\mathbb{N} \to \mathbb{R}^+$，$A$ 叫做 $U$ 的<strong>随机$f(n)$-近似算法</strong>，当满足对任意的 $x \in L_I$：<ul>
<li>$Prob(A(x) \in \mathcal{M}(x)) = 1$，</li>
<li>$Prob(R_A(x) \leq f(|x|)) \geq 1/2$。</li>
</ul>
</li>
<li>一个随机算法 $A$ 叫做 $U$ 的<strong>随机多项式时间近似方案（RPTAS）</strong>，如果存在一个函数 $p: L_I \times \mathbb{R}^+ \to \mathbb{N}$，使得对于任何输入 $(x, \delta) \in L_I \times \mathbb{R}^+$，满足：<ul>
<li>$Prob(A(x, \delta) \in  \mathcal{M}(x)) = 1$，对所有的选择 $A$ 都可以计算出一个可行解。</li>
<li>$Prob(\varepsilon_A(x, \delta) \leq \delta) \geq \dfrac{1}{2}$，一个可行解的相对误差不超过 $\delta$ 的概率大于 $1/2$。</li>
<li>$Time_A(x, \delta^{-1}) \leq p(|x| , \delta^{-1})$ 且 $p$ 是关于 $|x| $ 的多项式。</li>
</ul>
</li>
<li>类似的，如果 $p$ 是同时关于 $|x| $ 和 $\delta^{-1}$ 的多项式，$A$ 叫做 $U$ 的<strong>随机完全多项式时间近似方案（RFPTAS）</strong>。</li>
</ul>
<ul>
<li>$U = (\Sigma_I, \Sigma_O, L, L_I,\mathcal{M}, cost, goal)$ 是一个优化问题，对任意的实数 $\delta &gt; 1$，一个随机算法 $A$ 叫做 $U$ 的<strong>随机$\delta$-期望算法</strong>，当满足对任意的 $x\in L_I$：<ul>
<li>$Prob(A(x) \in \mathcal{M}(x)) = 1$，</li>
<li>$E[R_A(x)] \leq \delta$。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="随机算法的设计范式"><a href="#随机算法的设计范式" class="headerlink" title="随机算法的设计范式"></a>随机算法的设计范式</h1><h2 id="挫败敌人（Foiling-an-Adversary）"><a href="#挫败敌人（Foiling-an-Adversary）" class="headerlink" title="挫败敌人（Foiling an Adversary）"></a>挫败敌人（Foiling an Adversary）</h2><ul>
<li>对手论证</li>
<li>随机算法可以看作是确定性算法上的概率分布，对手可以构造一小部分很强（大开销）的确定性算法的输入，但很难设计击败随机算法的输入。</li>
</ul>
<h2 id="丰富的证人？（Abundance-of-Witnesses）"><a href="#丰富的证人？（Abundance-of-Witnesses）" class="headerlink" title="丰富的证人？（Abundance of Witnesses）"></a>丰富的证人？（Abundance of Witnesses）</h2><h2 id="指纹？（Fingerprinting）"><a href="#指纹？（Fingerprinting）" class="headerlink" title="指纹？（Fingerprinting）"></a>指纹？（Fingerprinting）</h2><h2 id="随机样本（Random-Sampling）"><a href="#随机样本（Random-Sampling）" class="headerlink" title="随机样本（Random Sampling）"></a>随机样本（Random Sampling）</h2><h2 id="（Relaxation-and-Random-Rounding）"><a href="#（Relaxation-and-Random-Rounding）" class="headerlink" title="（Relaxation and Random Rounding）"></a>（Relaxation and Random Rounding）</h2>]]></content>
      <categories>
        <category>problem-solving</category>
      </categories>
  </entry>
  <entry>
    <title>吴恩达机器学习笔记</title>
    <url>/2021/02/03/ML-AN/</url>
    <content><![CDATA[<h1 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a>Lecture 1</h1><h2 id="监督学习-Supervised-Learning"><a href="#监督学习-Supervised-Learning" class="headerlink" title="监督学习(Supervised Learning)"></a>监督学习(Supervised Learning)</h2><ul>
<li>监督学习指的就是我们给学习算法一个数据集。这个数据集由“正确答案”组成，再根据这些样本作出预测。</li>
<li>回归问题，即通过回归来推出一个<strong>连续</strong>的输出。</li>
<li>分类问题，其目标是推出一组<strong>离散</strong>的结果。</li>
</ul>
<a id="more"></a>
<h2 id="无监督学习-Unsupervised-Learning"><a href="#无监督学习-Unsupervised-Learning" class="headerlink" title="无监督学习(Unsupervised Learning)"></a>无监督学习(Unsupervised Learning)</h2><ul>
<li>在无监督学习中，我们已知的数据。不同于监督学习的数据，即无监督学习中没有任何的标签或者是有相同的标签或者就是没标签。</li>
<li>监督学习算法可能会把这些数据分成不同的簇，所以叫做聚类算法。</li>
</ul>
<p>分离音频代码: <code>[W,s,v] = svd((repmat(sum(x.*x,1),size(x,1),1).*x)*x&#39;)</code></p>
<hr>
<h1 id="Lecture-2"><a href="#Lecture-2" class="headerlink" title="Lecture 2"></a>Lecture 2</h1><p>本章主要介绍单变量线性回归问题，其中的一些基本概念和梯度下降法解决回归问题。</p>
<h2 id="模型表示-Model-Representation"><a href="#模型表示-Model-Representation" class="headerlink" title="模型表示(Model Representation)"></a>模型表示(Model Representation)</h2><p>在监督学习中我们有一个数据集，这个数据集被称训练集(Training Set)。</p>
<ul>
<li>$m$: 训练集中实例的数量</li>
<li>$x$: 特征/输入变量</li>
<li>$y$: 目标/输出变量</li>
<li>$(x, y)$: 训练集中的实例  </li>
<li>$(x^{(i)}, y^{(i)})$: 第$i$个观察实例  </li>
<li>$h$: 代表学习算法的解决方案或函数也称为假设函数(hypothesis), 从$x$到$y$的映射<ul>
<li>一种$h$的表达方式: $h_{\theta}(x) = \theta_{0} + \theta_{1}x$. 因为只含有一个特征/输入变量，因此这样的问题叫作单变量线性回归问题。</li>
</ul>
</li>
</ul>
<h2 id="代价函数-Cost-Function"><a href="#代价函数-Cost-Function" class="headerlink" title="代价函数(Cost Function)"></a>代价函数(Cost Function)</h2><p>我们现在要做的便是为我们的模型选择合适的<strong>参数</strong>(<strong>parameters</strong>) $\theta_{0}$和$\theta_{1}$, 我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距就是<strong>建模误差</strong>(<strong>modeling error</strong>)<br>我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数。 即使得代价函数 $J \left( \theta_0, \theta_1 \right) = \dfrac{1}{2m}\sum\limits_{i=1}^m \left( h_{\theta}(x^{(i)})-y^{(i)} \right)^{2}$ 最小。</p>
<ul>
<li><strong>代价函数</strong>也被称作平方误差函数，有时也被称为平方误差代价函数。对于大多数问题，特别是回归问题，都是一个合理的选择。</li>
</ul>
<h2 id="梯度下降-Gradient-Descent"><a href="#梯度下降-Gradient-Descent" class="headerlink" title="梯度下降(Gradient Descent)"></a>梯度下降(Gradient Descent)</h2><p>梯度下降是一个用来求函数最小值的算法，背后的思想是：开始时我们随机选择一个参数的组合$\left( {\theta_{0}},{\theta_{1}},……,{\theta_{n}} \right)$，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到找到一个局部最小值（<strong>local minimum</strong>），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（<strong>global minimum</strong>），选择不同的初始参数组合，可能会找到不同的局部最小值。<br>批量梯度下降(<strong>batch gradient descent</strong>)算法的公式为:<br><strong>repeat until convergence{</strong></p>
<script type="math/tex; mode=display">\theta_{j}:=\theta_{j}-\alpha \dfrac{\partial}{\partial \theta_{j}} J\left(\theta_{0}, \theta_{1}\right)</script><p><strong>}</strong></p>
<p>其中$\alpha$是学习率(<strong>learning rate</strong>)，它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大，在批量梯度下降中，我们每一次都<strong>同时</strong>让所有的参数减去学习速率乘以代价函数的导数。</p>
<h2 id="梯度下降的线性回归-Gradient-Descent-For-Linear-Regression"><a href="#梯度下降的线性回归-Gradient-Descent-For-Linear-Regression" class="headerlink" title="梯度下降的线性回归(Gradient Descent For Linear Regression)"></a>梯度下降的线性回归(Gradient Descent For Linear Regression)</h2><p>对我们之前的线性回归问题运用梯度下降法，关键在于求出代价函数的导数，即:<br>$\dfrac{\partial}{\partial \theta_{j}} J(\theta_{0}, \theta_{1}) = \dfrac{\partial}{\partial \theta_{j}} \dfrac{1}{2m}\sum\limits_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})^{2}$</p>
<p>$j=0$ 时：$\dfrac{\partial}{\partial \theta_{0}}J(\theta_{0}, \theta_{1}) = \dfrac{1}{m}\sum\limits_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})$</p>
<p>$j=1$ 时：$\dfrac{\partial}{\partial \theta_{1}}J(\theta_{0}, \theta_{1}) = \dfrac{1}{m}\sum\limits_{i=1}^{m}((h_{\theta}(x^{(i)}) - y^{(i)}) \cdot x^{(i)})$</p>
<p>则算法改写成:<br><strong>repeat until convergence{</strong></p>
<script type="math/tex; mode=display">\theta_{0} := \theta_{0} - \alpha \dfrac{1}{m}\sum\limits_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})</script><script type="math/tex; mode=display">\theta_{1} := \theta_{1} - \alpha \dfrac{1}{m}\sum\limits_{i=1}^{m}((h_{\theta}(x^{(i)}) - y^{(i)}) \cdot x^{(i)})</script><p>​               <strong>}</strong></p>
<ul>
<li>如果你之前学过线性代数, 你应该知道有一种计算代价函数$J$最小值的数值解法, 这是另一种称为正规方程(<strong>normal equations</strong>)的方法。</li>
<li>实际上在数据量较大的情况下，梯度下降法比正规方程要更适用一些。</li>
</ul>
<hr>
<h1 id="Lecture-3"><a href="#Lecture-3" class="headerlink" title="Lecture 3"></a>Lecture 3</h1><p>本章主要复习线性代数，虽然我线代没考好但是我觉得掌握的只是应该够用了，略(doge)。</p>
<hr>
<h1 id="Lecture-4"><a href="#Lecture-4" class="headerlink" title="Lecture 4"></a>Lecture 4</h1><h2 id="多维特征-Multiple-Features"><a href="#多维特征-Multiple-Features" class="headerlink" title="多维特征 Multiple Features"></a>多维特征 Multiple Features</h2><p>多个变量的模型中的特征为$\left( {x_{1}},{x_{2}},…,{x_{n}} \right)$。<br>新的注释:</p>
<ul>
<li>$n$: 特征的数量</li>
<li>$x^{\left( i \right)}$: 第 $i$ 个训练实例，是特征矩阵中的第$i$行，是一个<strong>向量</strong>（<strong>vector</strong>）</li>
<li>$x_{j}^{\left( i \right)}$: 特征矩阵中第 $i$ 行的第 $j$ 个特征，也就是第 $i$ 个训练实例的第 $j$ 个特征</li>
</ul>
<p>支持多变量的假设 $h$ 表示为：$h_{\theta}\left( x \right)=\theta_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}$，这个公式中有$n+1$个参数和$n$个变量，为了使得公式能够简化一些，引入$x_{0}=1$，则公式转化为：$h_{\theta} \left( x \right)=\theta_{0}x_{0} + \theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}$<br>此时模型中的参数是一个$n+1$维的向量，任何一个训练实例也都是$n+1$维的向量，特征矩阵$X$的维度是 $m*(n+1)$。 因此公式可以简化为：$h_{\theta} \left( x \right)=\theta^{T}X$，其中上标$T$代表矩阵转置。</p>
<h2 id="多变量梯度下降-Gradient-Descent-for-Multiple-Variables"><a href="#多变量梯度下降-Gradient-Descent-for-Multiple-Variables" class="headerlink" title="多变量梯度下降 Gradient Descent for Multiple Variables"></a>多变量梯度下降 Gradient Descent for Multiple Variables</h2><p>代价函数: $J\left( \theta_{0},\theta_{1}…\theta_{n} \right)=\dfrac{1}{2m}\sum\limits_{i=1}^{m}\left( h_{\theta} \left(x^{\left( i \right)} \right)-y^{\left( i \right)} \right)^{2}$<br>其中：$h_{\theta}\left( x \right)=\theta^{T}X=\theta_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}$， 我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。<br>算法为:<br><strong>repeat until convergence{</strong></p>
<script type="math/tex; mode=display">\theta_{j}:=\theta_{j}-\alpha \dfrac{\partial}{\partial \theta_{j}} J\left(\theta_{0}, \theta_{1}, ..., \theta_{n} \right)</script><p><strong>}</strong><br>即:<br><strong>repeat until convergence{</strong></p>
<script type="math/tex; mode=display">\theta_{j}:=\theta_{j}-\alpha \dfrac{\partial}{\partial \theta_{j}} \dfrac{1}{2m} \sum_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)}) ^{2}</script><p><strong>}</strong><br>求导后得:<br><strong>repeat until convergence{</strong></p>
<script type="math/tex; mode=display">\theta_{j}:=\theta_{j}-\alpha \dfrac{1}{m} \sum_{i=1}^{m}((h_{\theta}(x^{(i)}) - y^{(i)}) * x_{j}^{(i)})</script><p>(simultaneously update $\theta_{j}$ for $i = 1,2,…,n$)</p>
<p><strong>}</strong><br>我们开始随机选择一系列的参数值，计算所有的预测结果后，再给所有的参数一个新的值，如此循环直到收敛。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeCost</span>(<span class="params">X, y, theta</span>):</span></span><br><span class="line">    inner = np.power(((X * theta.T) - y), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">sum</span>(inner) / (<span class="number">2</span> * <span class="built_in">len</span>(X))</span><br></pre></td></tr></table></figure></p>
<h2 id="特征缩放-Feature-Scaling"><a href="#特征缩放-Feature-Scaling" class="headerlink" title="特征缩放 Feature Scaling"></a>特征缩放 Feature Scaling</h2><p>在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛(标准化，归一化)。</p>
<ul>
<li>最简单的方法是令：$x_{n}=\dfrac{x_{n}-\mu_{n}}{s_{n}}$，其中 $\mu_{n}$是平均值，$s_{n}$是标准差。</li>
</ul>
<h2 id="学习率-Learning-Rate"><a href="#学习率-Learning-Rate" class="headerlink" title="学习率 Learning Rate"></a>学习率 Learning Rate</h2><p>梯度下降算法的每次迭代受到学习率的影响，如果学习率$\alpha$过小，则达到收敛所需的迭代次数会非常高；如果学习率$\alpha$过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</p>
<h2 id="特征和多项式回归-Features-and-Polynomial-Regression"><a href="#特征和多项式回归-Features-and-Polynomial-Regression" class="headerlink" title="特征和多项式回归 Features and Polynomial Regression"></a>特征和多项式回归 Features and Polynomial Regression</h2><p>线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据, 通常我们需要先观察数据然后再决定准备尝试怎样的模型。</p>
<ul>
<li>我们可以令：$x_{2}=x^{2},x_{3}=x^{3}$，从而将模型转化为线性回归模型。</li>
<li>如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。</li>
</ul>
<h2 id="正规方程-Normal-Equation"><a href="#正规方程-Normal-Equation" class="headerlink" title="正规方程 Normal Equation"></a>正规方程 Normal Equation</h2><p>正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：$\dfrac{\partial}{\partial \theta_{j}}J\left( \theta_{j} \right)=0$ 。<br> 假设我们的训练集特征矩阵为 $X$（包含了 $x_{0}=1$）并且我们的训练集结果为向量 $y$，则利用正规方程解出向量 $\theta =\left( X^{T}X \right)^{-1}X^{T}y$.<br>上标$T$代表矩阵转置，上标$-1$代表矩阵的逆。</p>
<ul>
<li>只要特征变量的数目并不大，标准方程是一个很好的计算参数$\theta $的替代方法。具体地，只要特征变量数量小于一万，标准方程法，而不使用梯度下降法。</li>
</ul>
<h2 id><a href="#" class="headerlink" title></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalEqn</span>(<span class="params">X, y</span>):</span></span><br><span class="line">    theta = np.linalg.inv(X.T@X)@X.T@y <span class="comment">#X.T@X等价于X.T.dot(X)</span></span><br><span class="line">    <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure></h2><h1 id="Lecture-5"><a href="#Lecture-5" class="headerlink" title="Lecture 5"></a>Lecture 5</h1><p>本章主要是<strong>Ovtave</strong>的语法学习，现在基本使用<strong>Python</strong>，跳过本章。</p>
<hr>
<h1 id="Lecture-6"><a href="#Lecture-6" class="headerlink" title="Lecture 6"></a>Lecture 6</h1><p>本章主要是对于解决分类问题的逻辑回归算法的讲解。</p>
<h2 id="分类问题-Classification"><a href="#分类问题-Classification" class="headerlink" title="分类问题 Classification"></a>分类问题 Classification</h2><p>我们将因变量(<strong>dependent variable</strong>)可能属于的两个类分别称为负向类（<strong>negative class</strong>）和正向类（<strong>positive class</strong>），则因变量$y\in \{ 0,1 \}$ ，其中 0 表示负向类，1 表示正向类。</p>
<h2 id="假说表示-Hypothesis-Representation"><a href="#假说表示-Hypothesis-Representation" class="headerlink" title="假说表示 Hypothesis Representation"></a>假说表示 Hypothesis Representation</h2><p>我们希望我们的分类器的输出值在<strong>0和1之间</strong>，因此，我们希望想出一个满足某个性质的假设函数，这个性质是它的预测值要在0和1之间。<br>我们引入一个新的模型，逻辑回归，该模型的输出变量范围始终在0和1之间。<br>逻辑回归模型的假设是： $h_{\theta}(x) = g(\theta^{T}X)$<br>其中：<br>$X$ 代表特征向量<br>$g$ 代表逻辑函数（<strong>logistic function</strong>)是一个常用的逻辑函数为<strong>S</strong>形函数（<strong>Sigmoid function</strong>），公式为： $g(z) = \dfrac{1}{1 + e^{-z}}$.</p>
<figure class="highlight python"><figcaption><span>sigmoid</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br></pre></td></tr></table></figure>
<p>函数图像为:<br><img data-src="g.jpg" alt="sigmoid(z)"><br>$h_{\theta}( x )$的作用是，对于给定的输入变量，根据选择的参数计算输出变量=1的可能性（<strong>estimated probablity</strong>）即$h_{\theta} ( x )=P( y=1|x;\theta)$</p>
<h2 id="判定边界-Decision-Boundary"><a href="#判定边界-Decision-Boundary" class="headerlink" title="判定边界 Decision Boundary"></a>判定边界 Decision Boundary</h2><p>线性规划？反正就是约束条件所导致的曲线分界线。<br>我们可以用非常复杂的模型来适应非常复杂形状的判定边界。</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>对于线性回归模型，我们定义的代价函数是所有模型误差的平方和。理论上来说，我们也可以对逻辑回归模型沿用这个定义，但是问题在于，当我们将$h_{\theta}(x) = \dfrac{1}{1 + e^{-\theta^{T}X}}$带入到这样定义了的代价函数中时，我们得到的代价函数将是一个非凸函数（<strong>non-convexfunction</strong>）。<br>这意味着我们的代价函数有许多<strong>局部最小值</strong>，这将影响梯度下降算法寻找全局最小值。<br>我们重新定义逻辑回归的代价函数为: $J(\theta) = \dfrac{1}{m}\sum\limits_{i=1}^{n} Cost(h_{\theta}(x^{(i)}), y^{(i)})$, 其中</p>
<script type="math/tex; mode=display">Cost(h_{\theta}(x^{(i)}), y^{(i)})=\left\{
\begin{aligned}
- \log{(h_{\theta}(x))}, &y = 1\\
- \log{(1- h_{\theta}(x))}, &y = 0
\end{aligned}
\right.</script><p>再简化得:</p>
<script type="math/tex; mode=display">Cost(h_{\theta}(x^{(i)}), y^{(i)}) = -y \times \log{(h_{\theta}(x))} - (1 - y) \times \log{(1- h_{\theta}(x))}</script><p>带入代价函数得:</p>
<script type="math/tex; mode=display">J(\theta) = -\dfrac{1}{m}\sum\limits_{i=1}^{n} [y \times \log{(h_{\theta}(x))} + (1 - y) \times \log{(1- h_{\theta}(x))}]</script><figure class="highlight python"><figcaption><span>cost</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span>(<span class="params">theta, X, y</span>):</span></span><br><span class="line">    theta = np.matrix(theta)</span><br><span class="line">    X = np.matrix(X)</span><br><span class="line">    y = np.matrix(y)</span><br><span class="line">    first = np.multiply(-y, np.log(sigmoid(X* theta.T)))</span><br><span class="line">    second = np.multiply((<span class="number">1</span> - y), np.log(<span class="number">1</span> - sigmoid(X* theta.T)))</span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">sum</span>(first - second) / (<span class="built_in">len</span>(X))</span><br><span class="line"></span><br><span class="line"><span class="comment"># python实现的tips: 一般都是将输入用np.matrix向量化，再通过np的一些方法(np.sum, np.multiply)来运算，减少循环</span></span><br></pre></td></tr></table></figure>
<p>凸性分析的内容是超出这门课的范围的，但是可以证明我们所选的代价值函数会给我们一个凸优化问题。代价函数$J(\theta)$会是一个凸函数，并且没有局部最优值。</p>
<p>在得到这样一个代价函数以后，我们便可以用梯度下降算法来求得能使代价函数最小的参数了。<br><strong>repeat until convergence{</strong></p>
<script type="math/tex; mode=display">\theta_{j}:=\theta_{j}-\alpha \dfrac{\partial}{\partial \theta_{j}} J\left(\theta \right)</script><p><strong>}</strong></p>
<p>考虑$h_{\theta}(x) = \dfrac{1}{1 + e^{-\theta^{T}X}}$, 有：</p>
<script type="math/tex; mode=display">\dfrac{\partial}{\partial \theta_{j}} J(\theta) = \dfrac{1}{m} \sum\limits_{i=1}^{n} [(h_{\theta}(x^{(i)}) -y^{(i)}) x_{j}^{(i)}]</script><p><del>推导略，不信的话自己去算算</del></p>
<ul>
<li>虽然得到的梯度下降算法表面上看上去与线性回归的梯度下降算法一样，但是这里的$h_{\theta}(x)$与线性回归中不同，所以实际上是不一样的。另外，在运行梯度下降算法之前，进行特征缩放依旧是非常必要的。</li>
</ul>
<p>除了梯度下降算法以外，还有一些常被用来令代价函数最小的算法，这些算法更加复杂和优越，而且通常不需要人工选择学习率，通常比梯度下降算法要更加快速。这些算法有：<strong>共轭梯度</strong>（<strong>Conjugate Gradient</strong>），<strong>局部优化法</strong>(<strong>Broyden fletcher goldfarb shann,BFGS</strong>)和<strong>有限内存局部优化法</strong>(<strong>LBFGS</strong>) </p>
<h2 id="多类别分类-Multiclass-Classification"><a href="#多类别分类-Multiclass-Classification" class="headerlink" title="多类别分类 Multiclass Classification"></a>多类别分类 Multiclass Classification</h2><p>对每一个类别，创建一个新“伪”的训练集，拟合一个合适的分类器。<br>就是将一个类标为正类，其他都为负类，得到一系列模型记为$h_{\theta}^{(i)}(x) = p(y = i | x;\theta), i = 1,2,…,k$<br>最后，在我们需要做预测时，我们将所有的分类机都运行一遍，然后对每一个输入变量，都选择最高可能性的输出变量。</p>
<hr>
<h1 id="Lecture-7"><a href="#Lecture-7" class="headerlink" title="Lecture 7"></a>Lecture 7</h1><p>本章主要介绍<strong>正则化方法(Regularization)</strong>，它可以改善或者减少过度拟合问题。</p>
<h2 id="过拟合问题-Overfitting"><a href="#过拟合问题-Overfitting" class="headerlink" title="过拟合问题 Overfitting"></a>过拟合问题 Overfitting</h2><ul>
<li>丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如<strong>PCA</strong>）</li>
<li>正则化。 保留所有的特征，但是减少参数的大小（<strong>magnitude</strong>）。</li>
</ul>
<h2 id="代价函数-1"><a href="#代价函数-1" class="headerlink" title="代价函数"></a>代价函数</h2><p>某些项导致了过拟合的产生，所以如果我们能让这些项系数接近于0的话，我们就能很好的拟合了。<br>所以我们要做的就是在一定程度上减小这些参数$\theta$ 的值，这就是正则化的基本方法。我们要做的便是修改代价函数，为$\theta$设置一点惩罚。<br>假如我们有非常多的特征，我们并不知道其中哪些特征我们要惩罚，我们将对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设：</p>
<script type="math/tex; mode=display">J(\theta) = \dfrac{1}{2m}[\sum\limits_{i=1}^{m} (h_{\theta}(x^{(i)}) - y^{(i)})^{2} + \lambda \sum\limits_{j=1}^{n} \theta_{j}^{2}]</script><p>其中$\lambda$又称为正则化参数（<strong>Regularization Parameter</strong>）。 注：根据惯例，我们不对$\theta_{0}$ 进行惩罚。</p>
<h2 id="正则化线性回归-Regularized-Linear-Regression"><a href="#正则化线性回归-Regularized-Linear-Regression" class="headerlink" title="正则化线性回归 Regularized Linear Regression"></a>正则化线性回归 Regularized Linear Regression</h2><p><strong>repeat until convergence{</strong></p>
<script type="math/tex; mode=display">\theta_{0}:=\theta_{0}-\alpha \dfrac{1}{m} \sum_{i=1}^{m}((h_{\theta}(x^{(i)}) - y^{(i)})</script><script type="math/tex; mode=display">\theta_{j}:=\theta_{j}-\alpha [\dfrac{1}{m} \sum_{i=1}^{m}((h_{\theta}(x^{(i)}) - y^{(i)}) * x_{j}^{(i)}) + \dfrac{\lambda}{m}\theta_{j}] \quad (for~j=1,2,...,n)</script><p><strong>}</strong><br>对$j=1,2,…,n$时的更新式子整理得：</p>
<script type="math/tex; mode=display">\theta_{j}:=\theta_{j}(1 - \alpha \dfrac{\lambda}{m})-\alpha \dfrac{1}{m} \sum_{i=1}^{m}((h_{\theta}(x^{(i)}) - y^{(i)}) * x_{j}^{(i)})</script><p>可以看出，正则化线性回归的梯度下降算法的变化在于，每次都在原有算法更新规则的基础上令$\theta$值减少了一个额外的值。</p>
<p>我们同样也可以利用正规方程来求解正则化线性回归模型：</p>
<script type="math/tex; mode=display">\theta=\left(X^{T} X+\lambda\left[\begin{array}{cccc}
0 & & & \\
& 1 & & \\
& & 1 & & \\
& & & \ddots & \\
& & & & 1
\end{array}\right]\right)^{-1} X^{T} y</script><p>矩阵尺寸为 $(n+1)*(n+1)$。</p>
<h2 id="正则化的逻辑回归模型-Regularized-Logistic-Regression"><a href="#正则化的逻辑回归模型-Regularized-Logistic-Regression" class="headerlink" title="正则化的逻辑回归模型 Regularized Logistic Regression"></a>正则化的逻辑回归模型 Regularized Logistic Regression</h2><script type="math/tex; mode=display">J(\theta) = -\dfrac{1}{m}\sum\limits_{i=1}^{n} [y \times \log{(h_{\theta}(x))} + (1 - y) \times \log{(1- h_{\theta}(x))}] + \dfrac{\lambda}{2m} \sum\limits_{j=1}^{n}\theta_{j}^{2}</script><figure class="highlight python"><figcaption><span>python代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">costReg</span>(<span class="params">theta, X, y, learningRate</span>):</span></span><br><span class="line">    theta = np.matrix(theta)</span><br><span class="line">    X = np.matrix(X)</span><br><span class="line">    y = np.matrix(y)</span><br><span class="line">    first = np.multiply(-y, np.log(sigmoid(X*theta.T)))</span><br><span class="line">    second = np.multiply((<span class="number">1</span> - y), np.log(<span class="number">1</span> - sigmoid(X*theta.T)))</span><br><span class="line">    reg = (learningRate / (<span class="number">2</span> * <span class="built_in">len</span>(X))* np.<span class="built_in">sum</span>(np.power(theta[:,<span class="number">1</span>:theta.shape[<span class="number">1</span>]],<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">sum</span>(first - second) / (<span class="built_in">len</span>(X)) + reg</span><br></pre></td></tr></table></figure>
<p>梯度下降：<br><strong>repeat until convergence{</strong></p>
<script type="math/tex; mode=display">\theta_{0}:=\theta_{0}-\alpha \dfrac{1}{m} \sum_{i=1}^{m}((h_{\theta}(x^{(i)}) - y^{(i)})</script><script type="math/tex; mode=display">\theta_{j}:=\theta_{j}-\alpha [\dfrac{1}{m} \sum_{i=1}^{m}((h_{\theta}(x^{(i)}) - y^{(i)}) * x_{j}^{(i)}) + \dfrac{\lambda}{m}\theta_{j}] \quad (for~j=1,2,...,n)</script><p><strong>}</strong><br>注：看上去同线性回归一样，但是知道 $h_\theta ( x )=g( \theta^{T} X )$，所以与线性回归不同。</p>
<hr>
<h1 id="Lecture-8"><a href="#Lecture-8" class="headerlink" title="Lecture 8"></a>Lecture 8</h1><p>本章主要对<strong>神经网络Neural Network</strong>进行表述。</p>
<h2 id="非线性假设-Non-linear-Hypotheses"><a href="#非线性假设-Non-linear-Hypotheses" class="headerlink" title="非线性假设 Non-linear Hypotheses"></a>非线性假设 Non-linear Hypotheses</h2><p>当特征太多时，计算的负荷会非常大。<br>普通的逻辑回归模型，不能有效地处理这么多的特征，这时候我们需要神经网络。</p>
<h2 id="神经元和大脑-Neurons-and-the-Brain"><a href="#神经元和大脑-Neurons-and-the-Brain" class="headerlink" title="神经元和大脑 Neurons and the Brain"></a>神经元和大脑 Neurons and the Brain</h2><p><del>生物知识</del>。人工智能的梦想就是：有一天能制造出真正的智能机器。</p>
<h2 id="模型表示-Model-Representation-1"><a href="#模型表示-Model-Representation-1" class="headerlink" title="模型表示 Model Representation"></a>模型表示 Model Representation</h2><p>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元，<strong>activation unit</strong>）采纳一些特征作为输出，并且根据本身的模型提供一个输出。</p>
<p>下图是一个以逻辑回归模型作为自身学习模型的神经元示例，在神经网络中，参数又可被成为权重（<strong>weight</strong>）。</p>
<p><img data-src="neutral.png" alt="Neuron model"></p>
<p>我们设计出了类似于神经元的神经网络，效果如下：</p>
<p><img data-src="network.png" alt="Neural Network"></p>
<p>其中$x_1$, $x_2$, $x_3$是输入单元（<strong>input units</strong>），我们将原始数据输入给它们。</p>
<p>$a_1$, $a_2$, $a_3$是中间单元，它们负责将数据进行处理，然后呈递到下一层。</p>
<p>最后是输出单元，它负责计算$h_\theta ( x )$。</p>
<p>神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量。上图为一个三层神经网络，第一层称为输入层（<strong>Input Layer</strong>），最后一层称为输出层（<strong>Output Layer</strong>），中间一层成为隐藏层（<strong>Hidden Layers</strong>）。我们为每一层都增加一个偏差单位（<strong>bias unit</strong>）。</p>
<p>下面引入一些标记法来帮助描述模型：</p>
<ul>
<li>$a_{i}^{(j)}$：第$j$ 层的第 $i$ 个激活单元。</li>
<li>$\theta^{(j)}$：从第 $j$ 层映射到第$ j+1$ 层时的权重的矩阵。其尺寸为：以第 $j+1$层的激活单元数量为行数，以第 $j$ 层的激活单元数加一为列数的矩阵。</li>
</ul>
<p>对于上图所示的模型，激活单元和输出分别表达为：<br>$a_{1}^{(2)} = g(\Theta_{10}^{(1)}x_{0} + \Theta_{11}^{(1)}x_{1} + \Theta_{12}^{(1)}x_{2} +  \Theta_{13}^{(1)}x_{3})$</p>
<p>$a_{2}^{(2)} = g(\Theta_{20}^{(1)}x_{0} + \Theta_{21}^{(1)}x_{1} + \Theta_{22}^{(1)}x_{2} +  \Theta_{23}^{(1)}x_{3})$</p>
<p>$a_{3}^{(2)} = g(\Theta_{30}^{(1)}x_{0} + \Theta_{31}^{(1)}x_{1} + \Theta_{32}^{(1)}x_{2} +  \Theta_{33}^{(1)}x_{3})$</p>
<p>$h_{\Theta}(x) = g(\Theta_{10}^{(2)}a_{0} + \Theta_{11}^{(2)}a_{1} + \Theta_{12}^{(2)}a_{2} +  \Theta_{13}^{(2)}a_{3})$</p>
<p>上面进行的讨论中只是将特征矩阵中的一列（一个训练实例）喂给了神经网络，我们需要将整个训练集都喂给我们的神经网络算法来学习模型。</p>
<p>我们可以知道：每一个$a$都是由上一层所有的$x$和每一个$x$所对应的决定的。<br>（我们把这样从左到右的算法称为前向传播算法( <strong>FORWARD PROPAGATION</strong> )）</p>
<p>把$x$, $\theta$, $a$ 分别用矩阵表示，我们可以得到$\Theta \cdot X=a$ 。</p>
<p>我们可以把$a_0, a_1, a_2, a_3$看成更为高级的特征值，也就是$x_0, x_1, x_2, x_3$的进化体，并且它们是由 $x$与$\theta$决定的，因为是梯度下降的，所以$a$是变化的，并且变得越来越厉害，所以这些更高级的特征值远比仅仅将 $x$次方厉害，也能更好的预测新数据。</p>
<p>这就是神经网络相比于逻辑回归和线性回归的优势。</p>
<h2 id="多类分类"><a href="#多类分类" class="headerlink" title="多类分类"></a>多类分类</h2><p>当我们有不止两种分类时，输出层多个神经元来表示多类。</p>
<p>也就是每一个数据在输出层都会出$\{ a_{1}, a_{2}, …, a_{k} \}$，且$a_{i}$中仅有一个为1，表示当前类。</p>
<hr>
<h1 id="Lecture-9"><a href="#Lecture-9" class="headerlink" title="Lecture 9"></a>Lecture 9</h1><p>本章主要是神经网络的学习训练，其代价函数，检验以及初始化相关的介绍。</p>
<h2 id="代价函数-2"><a href="#代价函数-2" class="headerlink" title="代价函数"></a>代价函数</h2><p>首先引入一些标记：<br>假设神经网络的训练样本有 $m$ 个，每个包含一组输入 $x$ 和一组输出信号 $y$，$L$ 表示神经网络层数，$S_I$ 表示每层的<strong>neuron</strong>个数($S_l$ 表示输出层神经元个数)，$S_L$ 代表最后一层中处理单元的个数。<br>二类分类： $S_L = 0, y = 0 ~ or ~ 1$；<br>$K$类分类： $S_L = K, y_i = 1$ 表示分到第$i$类（$k &gt;2$）。</p>
<p>逻辑回归中的代价函数为：</p>
<script type="math/tex; mode=display">J(\theta) = -\dfrac{1}{m}\sum\limits_{i=1}^{n} [y \times \log{(h_{\theta}(x))} + (1 - y) \times \log{(1- h_{\theta}(x))}]</script><p>在逻辑回归中，只有一个输出变量，又称标量（<strong>scalar</strong>），也只有一个因变量$y$，但是在神经网络中，可以有很多输出变量，我们的$h_\theta(x)$是一个维度为$K$的向量，并且我们训练集中的因变量也是同样维度的一个向量，因此我们的代价函数会比逻辑回归更加复杂一些，为：<br>$h_{\theta} (x) \in \mathbb{R}^K$，$(h_{\theta} (x))_i = i$-th output</p>
<p>$J(\theta) = - \dfrac{1}{m} \left[ \sum\limits_{i = 1}^{m} \sum\limits_{k=1}^{K} y_k^{(i)} \log{(h_{\theta}(x^{(i)})_k)} + (1 - y_k^{(i)})\log{(1 - (h_{\theta} (x^{(i)}))_k)} + \dfrac{\lambda}{2m} \sum\limits_{l = 1}^{L-1} \sum\limits_{i=1}^{s_l}\sum\limits_{j=1}^{s_{l+1}} \right]$</p>
<p>这个看起来复杂很多的代价函数背后的思想还是一样的，我们希望通过代价函数来观察算法预测的结果与真实情况的误差有多大，唯一不同的是，对于每一行特征，我们都会给出$K$个预测，基本上我们可以利用循环，对每一行特征都预测$K$个不同结果，然后在利用循环在$K$个预测中选择可能性最高的一个，将其与$y$中的实际数据进行比较。</p>
<p>$h_\theta(x)$与真实值之间的距离为每个样本-每个类输出的加和，对参数进行<strong>regularization</strong>的<strong>bias</strong>项处理所有参数的平方和。</p>
<h2 id="反向传播算法-Backpropagation-Algorithm"><a href="#反向传播算法-Backpropagation-Algorithm" class="headerlink" title="反向传播算法 Backpropagation Algorithm"></a>反向传播算法 Backpropagation Algorithm</h2><p>为了计算代价函数的偏导数$\dfrac{\partial}{\partial\Theta^{(l)}_{ij}}J\left(\Theta\right)$，我们需要采用一种反向传播算法。也就是首先计算最后一层的误差，然后再一层一层反向求出各层的误差，直到倒数第二层。</p>
<p>e.g.<br>$K=4, S_L = 4,L=4$</p>
<p>从最后一层的误差开始计算，误差是激活单元的预测（$a^{(4)}$）与实际值（$y^k$）之间的误差，（$k=1:k$）。</p>
<p>我们用$\delta$来表示误差，则：$\delta^{(4)}=a^{(4)}-y$，然后利用这个误差值来计算前一层误差，则：$\delta^{(3)} = \left( \Theta^{(3)} \right)^T \delta^{(4)} * g’\left( z^{3} \right)$。</p>
<p>其中 $g’(z^{(3)})$是 $S$ 形函数的导数，$g’(z^{(3)})=a^{(3)}\ast(1-a^{(3)})$。而$(θ^{(3)})^{T}\delta^{(4)}$则是权重导致的误差的和。</p>
<p>我们有了所有的误差的表达式后，便可以计算代价函数的偏导数了，假设$λ=0$，即我们不做任何正则化处理时有：<br>$\dfrac{\partial}{\partial\Theta_{ij}^{(l)}}J(\Theta)=a_{j}^{(l)} \delta_{i}^{l+1}$</p>
<p>上面式子中上下标的含义：</p>
<ul>
<li>$l$：目前计算的是第几层。</li>
<li>$j$：目前计算的激活单元的下标，也将是下一层的第$j$个输入变量的下标。</li>
<li>$i$：下一层中误差单元的下标，是受到权重矩阵中第$i$行影响的下一层中的误差单元的下标。</li>
</ul>
<p>误差单元也是一个矩阵，我们用$\Delta^{(l)}_{ij}$来表示这个误差矩阵。第 $l$  层的第 $i$ 个激活单元受到第 $j$ 个参数影响而导致的误差。</p>
<p>算法表示为：<br><img data-src="backpropagation.jpg" alt="backporpagation algorithm"></p>
<p>即首先用正向传播方法计算出每一层的激活单元，利用训练集的结果与神经网络预测的结果求出最后一层的误差，然后利用该误差运用反向传播法计算出直至第二层的所有误差。</p>
<p>在求出了$\Delta_{ij}^{(l)}$之后，我们便可以计算代价函数的偏导数了，计算方法如下：<br>$D_{ij}^{(l)} :=\dfrac{1}{m}\Delta_{ij}^{(l)}+\lambda\Theta_{ij}^{(l)}$              ${if}\; j \neq  0$</p>
<p>$D_{ij}^{(l)} :=\dfrac{1}{m}\Delta_{ij}^{(l)}$                             ${if}\; j = 0$</p>
<ul>
<li>我们可以想象 $\delta^{(l)}_{j}$ 为函数求导时迈出的那一丁点微分，所以更准确的说 $\delta^{(l)}_{j}=\frac{\partial}{\partial z^{(l)}_{j}}cost(i)$</li>
</ul>
<h2 id="梯度检验-Gradient-Checking"><a href="#梯度检验-Gradient-Checking" class="headerlink" title="梯度检验 Gradient Checking"></a>梯度检验 Gradient Checking</h2><p>当我们对一个较为复杂的模型（例如神经网络）使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在不断减小，但最终的结果可能并不是最优解。<br>为了避免这样的问题，我们采取一种叫做梯度的数值检验（<strong>Numerical Gradient Checking</strong>）方法。这种方法的思想是通过估计梯度值来检验我们计算的导数值是否真的是我们要求的。<br>（就模拟求导看看我们用$\delta$算出来的对不对）</p>
<p>对$\theta_1$进行检验：<br> $\dfrac{\partial}{\partial\theta_1}=\dfrac{J\left(\theta_1+\varepsilon_1,\theta_2,\theta_3…\theta_n \right)-J \left( \theta_1-\varepsilon_1,\theta_2,\theta_3…\theta_n \right)}{2\varepsilon}$</p>
<p> 根据上面的算法，计算出的偏导数存储在矩阵 $D_{ij}^{(l)}$ 中。检验时，我们要将该矩阵展开成为向量，同时我们也将 $\theta$ 矩阵展开为向量，我们针对每一个 $\theta$ 都计算一个近似的梯度值，将这些值存储于一个近似梯度矩阵中，最终将得出的这个矩阵同 $D_{ij}^{(l)}$ 进行比较。</p>
<h2 id="随机初始化-Random-Initialization"><a href="#随机初始化-Random-Initialization" class="headerlink" title="随机初始化 Random Initialization"></a>随机初始化 Random Initialization</h2><p> 任何优化算法都需要一些初始的参数。到目前为止我们都是初始所有参数为0，这样的初始方法对于逻辑回归来说是可行的，但是对于神经网络来说是不可行的。如果我们令所有的初始参数都为0，这将意味着我们第二层的所有激活单元都会有相同的值。同理，如果我们初始所有的参数都为一个非0的数，结果也是一样的。</p>
<ul>
<li>我们通常初始参数为正负ε之间的随机值。</li>
</ul>
<h2 id="综合起来-Put-It-Together"><a href="#综合起来-Put-It-Together" class="headerlink" title="综合起来 Put It Together"></a>综合起来 Put It Together</h2><p>小结一下使用神经网络时的步骤：</p>
<ul>
<li><p>网络结构：第一件要做的事是选择网络结构，即决定选择多少层以及决定每层分别有多少个单元。</p>
<ul>
<li>第一层的单元数即我们训练集的特征数量。</li>
<li>最后一层的单元数是我们训练集的结果的类的数量。</li>
<li>如果隐藏层数大于1，确保每个隐藏层的单元个数相同，通常情况下隐藏层单元的个数越多越好。</li>
<li>我们真正要决定的是隐藏层的层数和每个中间层的单元数。</li>
</ul>
</li>
<li><p>训练神经网络</p>
<ol>
<li>参数的随机初始化。</li>
<li>利用正向传播方法计算所有的$h_{\theta}(x)$。</li>
<li>编写计算代价函数 $J$ 的代码。</li>
<li>利用反向传播方法计算所有偏导数。</li>
<li>利用数值检验方法检验这些偏导数。</li>
<li>使用优化算法来最小化代价函数。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="Lecture-10"><a href="#Lecture-10" class="headerlink" title="Lecture 10"></a>Lecture 10</h1><p>本章主要是吴恩达对于机器学习的一些技巧经验建议，包括如何调参，如何判断欠拟合或过拟合等等。<strong>本章非常重要</strong>，掌握了调参技巧可以节约非常多的<del>生命</del>时间。</p>
<h2 id="下一步做什么-Decide-What-to-Try-Next"><a href="#下一步做什么-Decide-What-to-Try-Next" class="headerlink" title="下一步做什么 Decide What to Try Next"></a>下一步做什么 Decide What to Try Next</h2><p>当我们运用训练好了的模型来预测未知数据的时候发现有较大的误差，我们下一步可以做什么？</p>
<ol>
<li>获得更多的训练样本——通常是有效的，但代价较大，下面的方法也可能有效，可考虑先采用下面的几种方法。</li>
<li>尝试减少特征的数量</li>
<li>尝试获得更多的特征</li>
<li>尝试增加多项式特征</li>
<li>尝试减少正则化程度$\lambda$</li>
<li>尝试增加正则化程度$\lambda$</li>
</ol>
<h2 id="评估一个假设-Evaluating-a-hypothesis"><a href="#评估一个假设-Evaluating-a-hypothesis" class="headerlink" title="评估一个假设 Evaluating a hypothesis"></a>评估一个假设 Evaluating a hypothesis</h2><p>当我们确定学习算法的参数的时候，我们考虑的是选择参量来使训练误差最小化，有人认为得到一个非常小的训练误差一定是一件好事，但我们已经知道，仅仅是因为这个假设具有很小的训练误差，并不能说明它就一定是一个好的假设函数。而且我们也学习了过拟合假设函数的例子，所以这推广到新的训练集上是不适用的。</p>
<p>所以我们时常需要判断一个假设函数是否过拟合或欠拟合。</p>
<p>我们可以对假设函数$h(x)$进行画图，然后观察图形趋势，但对于有很多特征变量的问题，想要通过画出假设函数来进行观察，就会变得很难甚至是不可能实现。</p>
<p>另一种方法检验是否过拟合，将数据分成训练集和测试集，通常用70%的数据作为训练集，用剩下30%的数据作为测试集，如果数据有某种规律，要打乱再分。</p>
<p>测试集是用来评估训练集训练出的学习模型的参数，对测试集运用该模型，计算误差：</p>
<ul>
<li>线性回归模型，计算测试集数据的代价函数 $J$</li>
<li>逻辑回归模型，除了代价函数 $J_{t e s t}(\theta)=-\dfrac{1}{m_{\text {test }}} \sum\limits_{i=1}^{m_{test }} y_{test}^{(i)} \log h_{\theta}(x_{test }^{(i)})+(1-y_{test }^{(i)}) \log h_{\theta}(x_{test }^{(i)})$，我们还可以计算错误分类的比率: $err(h_{\theta}(x), y)=\left\{\begin{array}{c}<br>1 \text { ,if } h(x) \geq 0.5 \text { and } y=0, \text { or if } h(x)&lt;0.5 \text { and } y=1 \\<br>0 \text { ,otherwise }<br>\end{array}\right.$ ，再求平均。</li>
</ul>
<h2 id="模型选择和交叉验证集-Model-Selection-and-Train-Validation-Test-Sets"><a href="#模型选择和交叉验证集-Model-Selection-and-Train-Validation-Test-Sets" class="headerlink" title="模型选择和交叉验证集 Model Selection and Train_Validation_Test Sets"></a>模型选择和交叉验证集 Model Selection and Train_Validation_Test Sets</h2><p>我们需要使用交叉验证集来帮助选择模型（多项式次数）。</p>
<p>使用60%的数据作为训练集，使用 20%的数据作为交叉验证集，使用20%的数据作为测试集。</p>
<p>模型选择的方法：</p>
<ol>
<li>用训练集训练出10个模型</li>
<li>用10个模型分别对交叉验证集计算得出交叉验证误差（代价函数的值）</li>
<li>选取代价函数值最小的模型</li>
<li>用步骤3中选出的模型对测试集计算得出推广误差（代价函数的值）</li>
</ol>
<h2 id="诊断偏差和方差-Diagnosing-Bias-vs-Variance"><a href="#诊断偏差和方差-Diagnosing-Bias-vs-Variance" class="headerlink" title="诊断偏差和方差 Diagnosing Bias vs. Variance"></a>诊断偏差和方差 Diagnosing Bias vs. Variance</h2><p>当运行一个学习算法时，如果这个算法的表现不理想，那么多半是出现两种情况：要么是偏差比较大，要么是方差比较大。换句话说，出现的情况要么是欠拟合，要么是过拟合问题。</p>
<p>我们通常会通过将训练集和交叉验证集的代价函数误差与多项式的次数绘制在同一张图表上来帮助分析：</p>
<p><img data-src="train_cv_with_degree.png" alt title="训练集和交叉验证集的代价函数和次数的关系"></p>
<p>对于训练集，当 $d$ 较小时，模型拟合程度更低，误差较大；随着 $d$ 的增长，拟合程度提高，误差减小。</p>
<p>对于交叉验证集，当 $d$ 较小时，模型拟合程度低，误差较大；但是随着 $d$ 的增长，误差呈现先减小后增大的趋势，转折点是我们的模型开始过拟合训练数据集的时候。</p>
<ul>
<li>训练集误差和交叉验证集误差近似时：偏差/欠拟合。</li>
<li>交叉验证集误差远大于训练集误差时：方差/过拟合。</li>
</ul>
<h2 id="正则化和偏差-方差-Regularization-and-Bias-Variance"><a href="#正则化和偏差-方差-Regularization-and-Bias-Variance" class="headerlink" title="正则化和偏差/方差 Regularization and Bias_Variance"></a>正则化和偏差/方差 Regularization and Bias_Variance</h2><p>在我们在训练模型的过程中，一般会使用一些正则化方法来防止过拟合。但是我们可能会正则化的程度太高或太小了，即我们在选择λ的值时也需要思考与刚才选择多项式模型次数类似的问题。</p>
<p>我们选择一系列的想要测试的 $\lambda$ 值，通常是 0-10之间的呈现2倍关系的值（如：$0,0.01,0.02,0.04,0.08,0.15,0.32,0.64,1.28,2.56,5.12,10$共12个）。 我们同样把数据分为训练集、交叉验证集和测试集。</p>
<p>选择 $\lambda$ 的方法为：</p>
<ol>
<li>使用训练集训练出12个不同程度正则化的模型</li>
<li>用12个模型分别对交叉验证集计算的出交叉验证误差</li>
<li>选择得出交叉验证误差<strong>最小</strong>的模型</li>
<li>运用步骤3中选出模型对测试集计算得出推广误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与λ的值绘制在一张图表上：<ul>
<li>注意到这里训练的时候加正则项，评估的时候不要正则项。</li>
</ul>
</li>
</ol>
<p><img data-src="lambda.png" alt title="训练集和交叉验证集的代价函数和lambda的关系"></p>
<p>• 当 $\lambda$ 较小时，训练集误差较小（过拟合）而交叉验证集误差较大</p>
<p>• 随着 $\lambda$ 的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加</p>
<h2 id="学习曲线-Learning-Curves"><a href="#学习曲线-Learning-Curves" class="headerlink" title="学习曲线 Learning Curves"></a>学习曲线 Learning Curves</h2><p>学习曲线是学习算法的一个很好的<strong>合理检验</strong>（<strong>sanity check</strong>）。学习曲线是将训练集误差和交叉验证集误差作为训练集样本数量（$m$）的函数绘制的图表。</p>
<p>当训练较少行数据的时候，训练的模型将能够非常完美地适应较少的训练数据，但是训练出来的模型却不能很好地适应交叉验证集数据或测试集数据。</p>
<ul>
<li>高偏差/欠拟合时，交叉验证集和训练集的曲线会很接近，无论训练集有多么大误差都不会有太大改观：<img data-src="high_bias.png" alt title="高偏差的学习曲线"></li>
</ul>
<ul>
<li><p>高方差/过拟合时，训练集误差很小，交叉验证集误差远大于训练集误差，往训练集增加更多数据可以提高模型的效果：</p>
<p><img data-src="high_variance.png" alt title="高方差的学习曲线"></p>
</li>
</ul>
<h2 id="决定下一步做什么-Deciding-What-to-Do-Next-Revisite"><a href="#决定下一步做什么-Deciding-What-to-Do-Next-Revisite" class="headerlink" title="决定下一步做什么 Deciding What to Do Next Revisite"></a>决定下一步做什么 Deciding What to Do Next Revisite</h2><p>回顾 1.1 中提出的六种可选的下一步，让我们来看一看我们在什么情况下应该怎样选择：</p>
<ol>
<li><p>获得更多的训练样本——解决高方差</p>
</li>
<li><p>尝试减少特征的数量——解决高方差</p>
</li>
<li><p>尝试获得更多的特征——解决高偏差</p>
</li>
<li><p>尝试增加多项式特征——解决高偏差</p>
</li>
<li><p>尝试减少正则化程度λ——解决高偏差</p>
</li>
<li><p>尝试增加正则化程度λ——解决高方差</p>
</li>
</ol>
<p>神经网络的方差和偏差：<br><img data-src="/neutral_overfitting.png" alt title="神经网路的过拟合"></p>
<p>使用较小的神经网络，类似于参数较少的情况，容易导致高偏差和欠拟合，但计算代价较小使用较大的神经网络，类似于参数较多的情况，容易导致高方差和过拟合，虽然计算代价比较大，但是可以通过正则化手段来调整而更加适应数据。</p>
<ul>
<li>通常选择较大的神经网络并采用正则化处理会比采用较小的神经网络效果要好。</li>
</ul>
<p>对于神经网络中的隐藏层的层数的选择，通常从一层开始逐渐增加层数，为了更好地作选择，可以把数据分为训练集、交叉验证集和测试集，针对不同隐藏层层数的神经网络训练神经网络，<br>然后选择交叉验证集代价最小的神经网络。</p>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习笔记</title>
    <url>/2021/01/28/python-learning/</url>
    <content><![CDATA[<p><strong><em>持续更新中</em></strong><br>参考: <a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰python教程</a></p>
<h1 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>整数(Python可以处理任意大)，浮点数，字符串(<code>&#39;&#39;</code>或<code>&quot;&quot;</code>括起来的，<code>\</code>转义)，布尔值(<code>True</code> or <code>False</code>)，空值(<code>None</code>).</li>
<li>在Python中，等号<code>=</code>是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量(动态语言)。</li>
<li>Python3用Unicode编码，提供<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符。</li>
<li>把<code>str</code>变为以字节为单位的<code>bytes</code>型，带<code>b</code>前缀的的单引号或双引号表示。<code>encode()</code>, <code>decode()</code></li>
<li>格式化字符串规则和c语言类似。</li>
</ul>
<a id="more"></a>
<h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h3><ul>
<li>[ ]表示list</li>
<li>[ ]下标索引，从0开始，负数表示倒数第几个</li>
<li>list中数据类型可以不同，可以嵌套</li>
</ul>
<figure class="highlight python"><figcaption><span>list</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(mylist) <span class="comment">#获得list元素的个数 </span></span><br><span class="line">mylist.append(<span class="string">&#x27;a&#x27;</span>) <span class="comment"># 往list中追加元素到末尾</span></span><br><span class="line">mylist.insert(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>) <span class="comment"># 把元素插入到指定位置</span></span><br><span class="line">mylist.pop() <span class="comment"># 删除list末尾的元素</span></span><br><span class="line">mylist.pop(<span class="number">1</span>) <span class="comment"># 删除指定位置的元素</span></span><br><span class="line"><span class="comment">#pop返回值为被删除的元素</span></span><br><span class="line"><span class="keyword">del</span> mylist[<span class="number">1</span>] <span class="comment">#使用del可以删除任何位置的列表元素，条件是知道索引</span></span><br><span class="line">mylist.remove() <span class="comment">#按值删除元素，只删除第一个指定的值</span></span><br><span class="line"><span class="comment"># `pop和`del`的选择：删除后是否还要使用该元素</span></span><br><span class="line">mylist.sort() <span class="comment">#永久排序</span></span><br><span class="line">mylist.sort(reverse = <span class="literal">True</span>) <span class="comment">#倒序排序</span></span><br><span class="line"><span class="built_in">sorted</span>(mylist) <span class="comment">#暂时排序，也可以加入倒序参数</span></span><br><span class="line">mylist.reverse() <span class="comment">#永久倒置</span></span><br><span class="line">mylist[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#list切片，同MATLAB，首尾可缺省</span></span><br><span class="line">copy_list = mylist[:] <span class="comment">#通过切片赋值list</span></span><br></pre></td></tr></table></figure>
<h3 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h3><ul>
<li><code>( )</code>表示元组</li>
<li>tuple和list非常类似，但是tuple一旦初始化就<strong>不能修改</strong>，类似enum</li>
<li>定义一个元素就加个<code>,</code></li>
<li><code>tuple</code>的不变是<strong>指向不变</strong>，即给元组变量赋值是合法的</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><ul>
<li>不要括号，冒号换行，缩进</li>
<li><code>else if</code>可以缩写<code>elif</code></li>
<li><code>if a in mylist</code>判断元素是否在列表(很自然语言)</li>
</ul>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><ul>
<li><code>for x in ...</code>按list或tuple迭代</li>
<li><code>range(m,n,step)</code>函数生成从m开始到n的整数序列，步长为step，<code>m</code>缺省为0，<code>step</code>缺省为1</li>
</ul>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><ul>
<li><code>break</code>, <code>continue</code>正常用</li>
</ul>
<h3 id="dict字典"><a href="#dict字典" class="headerlink" title="dict字典"></a>dict字典</h3><ul>
<li>key-value, 查找速度很快；类似map, hash table</li>
<li>key必须是<strong>不可变</strong>对象</li>
<li><code>&#123;&#39;key&#39;: value, ...&#125;</code>创建</li>
</ul>
<figure class="highlight python"><figcaption><span>dict</span></figcaption><table><tr><td class="code"><pre><span class="line">d.get(<span class="string">&#x27;Thomas&#x27;</span>,-<span class="number">1</span>) <span class="comment">#寻找某个关键字的值，-1是规定的不存在时的返回值，缺省时返回None，Python交互环境不显示结果</span></span><br><span class="line">d.pop(<span class="string">&#x27;Bob&#x27;</span>) <span class="comment">#删除一个关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> d.items(): <span class="comment"># 使用items()方法可以访问所有条目</span></span><br><span class="line">    print(key + <span class="string">&quot;:&quot;</span> + value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.keys(): <span class="comment"># 使用keys()方法可以访问所有的关键字</span></span><br><span class="line">    print(key.title())</span><br></pre></td></tr></table></figure>
<h3 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h3><ul>
<li>无序，不重复元素，不能放入可变对象</li>
</ul>
<figure class="highlight python"><figcaption><span>set</span></figcaption><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s.add(<span class="number">4</span>) <span class="comment">#添加元素</span></span><br><span class="line">s.remove(<span class="number">4</span>) <span class="comment">#删除元素</span></span><br><span class="line">s1 &amp; s2 <span class="comment">#交集</span></span><br><span class="line">s1 | s2 <span class="comment">#并集</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不可变对象：调用对象自身的方法不会改变该对象自身的内容，而是会创建新的对象并返回，如str</li>
<li>可变对象：恰恰相反，如list</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Python内置函数: <a href="http://docs.python.org/3/library/functions.html#abs">python手册</a><br>函数名就是指向函数对象的引用，可以当变量用(太骚了)。</p>
<figure class="highlight python"><figcaption><span>define_function</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>funct_with_arg_check</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x,(<span class="built_in">int</span>, <span class="built_in">float</span>)): <span class="comment">#数据类型检查</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>) <span class="comment">#异常处理(后续会提到)</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>multi_return_value</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">x, y, step, angle=<span class="number">0</span></span>):</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure>
<p>返回多值其实是返回一个tuple, 这点比c好用多了!</p>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p><code>def power(x, n=2)</code>缺省时取默认值。</p>
<ul>
<li>必选参数在前，可选参数在后</li>
<li>变化大的参数在前，变化小的参数在后，降低调用难度</li>
<li>默认参数必须指向<strong>不变对象</strong></li>
</ul>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。<br>参数前加<code>*</code>，可以传入任意个参数。list或tuple前加<code>*</code>表示把list或tuple的所有元素作为可变参数。<br><figure class="highlight python"><figcaption><span>changeable_args</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">*numbers</span>):</span> <span class="comment">#加*表示可变参数</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        ans += n * n</span><br><span class="line">    <span class="keyword">return</span> ans   </span><br><span class="line"><span class="comment">#传参</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#传递变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cal(*number) <span class="comment">#传递list和tuple</span></span><br></pre></td></tr></table></figure></p>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。<br>参数前加<code>**</code>，可以传入任意个关键字参数，dict前加<code>**</code>表示把这个dict的所有key-value作为参数。</p>
<h2 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h2><p>限制关键字名字。</p>
<ul>
<li>需要一个特殊分隔符<code>*</code>, 后面跟命名关键字参数。如果有可变参数，就不需要<code>*</code></li>
<li>必须传入参数名，否则报错；可以设置默认缺省值</li>
</ul>
<figure class="highlight python"><figcaption><span>key_args</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, **kw</span>):</span> <span class="comment">#表示接受关键字参数`kw`</span></span><br><span class="line">    print(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Michael&#x27;</span>, <span class="number">30</span>) <span class="comment">#可以只传入必选参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">45</span>, gender=<span class="string">&#x27;M&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">45</span>, **extra) <span class="comment">#将现成的dict作为参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, **kw</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;city&#x27;</span> <span class="keyword">in</span> kw: <span class="comment">#有city参数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;job&#x27;</span> <span class="keyword">in</span> kw: <span class="comment">#有job参数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, *, city, job</span>):</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, *args, city, job</span>):</span></span><br></pre></td></tr></table></figure>
<p>所有这些参数都能组合使用，理论上任意函数都可以通过<code>f(*args,**kw)</code>调用。不要使用太多组合，保持接口的可理解性。</p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>Python没有尾递归优化。</p>
<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>有点类似verilog里面的索引，但更高级而且范围不同。</p>
<figure class="highlight python"><figcaption><span>slice</span></figcaption><table><tr><td class="code"><pre><span class="line">L[head : tail :step] <span class="comment">#范围[head,tail),[head,tail-1]</span></span><br><span class="line">L[:<span class="number">3</span>] <span class="comment">#取出从第0个到第3个元素</span></span><br><span class="line">L[-<span class="number">2</span>:] <span class="comment">#取出倒数第2个到最后1个</span></span><br><span class="line">L[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#取出从第1个到第3个元素</span></span><br><span class="line">L[:<span class="number">10</span>:<span class="number">2</span>] <span class="comment">#前10个数，每2个取一个</span></span><br><span class="line">L[::<span class="number">5</span>] <span class="comment">#所有数，每5个取一个</span></span><br><span class="line">L[:] <span class="comment">#原样复制一个list</span></span><br><span class="line"><span class="string">&#x27;ABCDEFG&#x27;</span>[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#字符串也可以看成List</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>啥都能迭代</p>
<figure class="highlight python"><figcaption><span>iteration</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>]):</span><br><span class="line">    print(i, value)</span><br><span class="line"><span class="comment"># enumerate可以将list变成索引-元素对，相当于数组</span></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">9</span>)]:</span><br><span class="line">    print(x,y)</span><br><span class="line"><span class="comment">#同时对两个变量进行迭代</span></span><br></pre></td></tr></table></figure>
<p>通过collections模块的Iterable类型判断一个对象是否可迭代<br><figure class="highlight python"><figcaption><span>iterable</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>太自然语言了。。。<br><figure class="highlight python"><figcaption><span>listgenerator</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块，模块的概念后面讲到</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>)] <span class="comment"># os.listdir可以列出文件和目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)] <span class="comment">#if在前在后的区别</span></span><br></pre></td></tr></table></figure></p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>一边循环一边计算的机制，generator。列表生成式的<code>[]</code>改成<code>()</code></p>
<ul>
<li>list保存的是数据，generator保存的是算法。</li>
<li>使用<code>next()</code>获得generator的下一个返回值。</li>
<li>generator是可迭代对象。</li>
<li>函数定义中包含关键字<code>yield</code>，就是一个generator。执行流程和函数不一样，遇到<code>yield</code>返回，再次执行从上次<code>yield</code>继续。</li>
<li>遇到return或执行到函数体的最后一句，generator结束，for循环结束。</li>
</ul>
<figure class="highlight python"><figcaption><span>generator</span></figcaption><table><tr><td class="code"><pre><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)) <span class="comment">#把list的[]变成()就可以得到生成器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(n &lt; <span class="built_in">max</span>):</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        <span class="comment">#相当于(a,b) = (b, a+b)</span></span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>可以直接作用于<code>for</code>循环的对象统称为可迭代对象<code>iterable</code>, 使用<code>isinstance( , Iterable)</code>判断。(list, dict, str, generator)</li>
<li>可以被<code>next()</code>调用并返回下个值对象称为迭代器<code>iterator</code>, 使用<code>isinstance( , Iterator)</code>判断。(generator)</li>
<li><code>iter()</code>可以把<code>iterable</code>变成<code>iterator</code></li>
</ul>
<p>Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。(yls好像讲过这个owo)</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！(函数名也是变量)</p>
<h2 id="高阶函数-High-order-function"><a href="#高阶函数-High-order-function" class="headerlink" title="高阶函数 High-order-function"></a>高阶函数 High-order-function</h2><p>变量可以指向函数，函数的参数能接收变量，一个函数就可以接收另一个函数作为参数，这种函数就称之为<strong>高阶函数</strong>。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>接收两个参数，一个是函数，一个是<code>Iterable</code>，函数依次作用到每个元素，结果作为新的<code>Iterator</code>返回。<br><figure class="highlight python"><figcaption><span>map</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>接收两个参数，一个是函数，一个是<code>Iterable</code>, 函数必须接受两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，效果为<code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code><br><figure class="highlight python"><figcaption><span>str2int</span></figcaption><table><tr><td class="code"><pre><span class="line">num = &#123;<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>:<span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>:<span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>:<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2num</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">x,y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">char2num</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> num[s]</span><br><span class="line">    <span class="keyword">return</span> reduce(fn, <span class="built_in">map</span>(char2num, s))</span><br></pre></td></tr></table></figure></p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>接收一个函数和一个序列，把函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br><figure class="highlight python"><figcaption><span>primes</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_odd_iter</span>():</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_not_divisible</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = _odd_iter() <span class="comment"># 初始序列</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="built_in">next</span>(it) <span class="comment"># 返回序列的第一个数</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = <span class="built_in">filter</span>(_not_divisible(n), it) <span class="comment"># 构造新序列</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>filter()</code>的作用是从一个序列中筛出符合条件的元素。由于<code>filter()</code>使用了惰性计算，所以只有在取<code>filter()</code>结果的时候，才会真正筛选并每次返回下一个筛出的元素。</li>
</ul>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h3><p>接受一个<code>key</code>函数来实现自定义排序，<code>reverse</code>决定正着还是反着排。<br><code>sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)</code></p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>函数作为返回值的函数。</p>
<ul>
<li>闭包(closure): 内部函数可以引用外部函数的参数和局部变量，返回时，相关参数和局部变量都保存在返回的函数中。</li>
<li>返回的函数不会立刻执行，而是等到调用了才执行。</li>
<li><strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></li>
</ul>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>不需要显式地定义函数，关键字<code>lambda</code>表示匿名函数，冒号前的变量表示参数。</p>
<ul>
<li>只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</li>
</ul>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator），本质上就是一个返回函数的高阶函数。</p>
<ul>
<li>函数有一个<code>__name__</code>属性，可以获得函数的名字。</li>
</ul>
<figure class="highlight python"><figcaption><span>decorator</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)  </span><span class="comment">#将原始函数的属性复制到wapper中</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">            print(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))   <span class="comment">#函数调用之外的作用</span></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)    <span class="comment">#调用原函数</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log </span><span class="comment"># @语法，相当于执行now=log(now)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span>():</span></span><br><span class="line">    print(<span class="string">&quot;2021-1-29&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2021</span>-<span class="number">1</span>-<span class="number">29</span></span><br></pre></td></tr></table></figure>
<p>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。<br>decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>把一个函数的某些参数固定住(设置一个参数的默认值)，返回一个新的函数，可以直接调用这个新的函数。<code>functools.partial(f, args, **kw)</code><br><code>int2 = functools.partial(int, base=2)</code></p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><ul>
<li>一个<code>.py</code>文件就是一个模块。</li>
<li>提高了代码的可维护性。编写程序的时候，经常引用其他模块，包括Python内置的模块和来自第三方的模块。</li>
<li>避免了函数名冲突，尽量不要与内置函数名字冲突。自己创建模块时要注意命名，一定不能和Python自带的模块名称冲突。</li>
<li>为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。<ul>
<li>模块名为”包名.模块名”</li>
<li>每个包必须有一个<code>__init__.py</code>文件</li>
<li>包可以再套娃，多级层次包结构</li>
</ul>
</li>
</ul>
<h2 id="标准模块文件"><a href="#标准模块文件" class="headerlink" title="标准模块文件"></a>标准模块文件</h2><figure class="highlight python"><figcaption><span>std-module</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; a test module &#x27;</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;Michael Liao&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure>
<ul>
<li>第1行和第2行是标准注释，第1行注释可以让这个文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码。</li>
<li>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释。</li>
<li>第6行使用<strong>author</strong>变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名。</li>
</ul>
<h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p><code>import sys</code>获得变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。</p>
<ul>
<li>模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。</li>
<li>命令行中变量<code>__name__ == __main__</code></li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>正常的函数和变量名是公开的(public)，可以直接被引用。</li>
<li>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，我们自己的变量一般不要用这种变量名。</li>
<li>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，只应该在模块内部引用。</li>
<li>这是一种非常有用的代码封装和抽象的方法，外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</li>
</ul>
<h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。<br><code>pip install [模块名]</code></p>
<h1 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程 OOP"></a>面向对象编程 OOP</h1><ul>
<li>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的<strong>类</strong>（Class）的概念。</li>
<li>对象拥有<strong>属性</strong>（Property）, 调用对象对应的关联函数，我们称之为对象的<strong>方法</strong>（Method）。</li>
</ul>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p><code>class [Class name](object):</code></p>
<p><code>class</code>后面紧接着是类名，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的。通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>创建实例：类名+()</li>
<li>可以自由地给一个实例变量绑定属性</li>
<li>通过<code>__init__</code>方法在创建实例时把一些我们认为必须绑定的属性强制填写进去。<ul>
<li>和普通的函数相比，在类中定义的函数只有一点不同，就是<strong>第一个</strong>参数永远是实例变量<code>self</code>(cpp的<code>this</code>)，调用时不用传递</li>
</ul>
</li>
</ul>
<figure class="highlight python"><figcaption><span>class-definition</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br></pre></td></tr></table></figure>
<p>数据封装，类方法，和cpp类似</p>
<h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><ul>
<li>私有变量：名称前加两个下划线<code>__xxx</code>，外部无法访问(其实只是Python解释器把它解释为了另一个名字)。</li>
<li>双下划线开头双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量。</li>
<li>单下划线开头的，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</li>
</ul>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><ul>
<li>子类继承父类的方法，相同的方法子类覆盖父类。</li>
<li>多态：对于一个变量，我们只需要知道它是父类型，无需确切地知道它的子类型，就可以放心地调用某个方法，而具体调用的方法是作用在对象上，由运行时该对象的确切类型决定。<ul>
<li>这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种子类时，只要确保方法编写正确，不用管原来的代码是如何调用的。</li>
<li>开闭原则：对扩展开放，允许新增子类；对修改封闭：不需要修改依赖父类型的函数。</li>
</ul>
</li>
<li>比java等静态语言更开放的，不要求严格的继承体系，调用方法时只要保证对象有这样的方法。<ul>
<li>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</li>
</ul>
</li>
</ul>
<h2 id="获得对象信息"><a href="#获得对象信息" class="headerlink" title="获得对象信息"></a>获得对象信息</h2><ul>
<li><code>type()</code>函数，返回对应的Class类型。<ul>
<li><code>int</code>, <code>str</code>可以直接做数据类型关键字。</li>
<li><code>types</code>模块中定义有各种数据类型的常量。</li>
</ul>
</li>
<li><code>isinstance()</code>函数，判断是否是某种类型。<ul>
<li>总是优先使用<code>isinstance()</code>判断类型，可以将指定类型及其子类“一网打尽”。</li>
</ul>
</li>
<li><code>dir()</code>函数，获得一个对象的所有属性和方法，返回一个包含字符串的list。<ul>
<li>配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态</li>
</ul>
</li>
</ul>
<figure class="highlight python"><figcaption><span>class</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;x&#x27;</span>) <span class="comment"># 有属性&#x27;x&#x27;吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 有属性&#x27;y&#x27;吗？</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">setattr</span>(obj, <span class="string">&#x27;y&#x27;</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性&#x27;y&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 有属性&#x27;y&#x27;吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 获取属性&#x27;y&#x27;</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性&#x27;y&#x27;</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 有属性&#x27;power&#x27;吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;并赋值到变量fn</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>
<p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法</p>
<ul>
<li>只有在不知道对象具体信息时，才会去获取对象的信息</li>
</ul>
<figure class="highlight python"><figcaption><span>good-example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readImage</span>(<span class="params">fp</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(fp, <span class="string">&#x27;read&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> readData(fp)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="comment"># 假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取</span></span><br></pre></td></tr></table></figure>
<h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><ul>
<li>给实例绑定属性的方法是通过实例变量，或者通过self变量。</li>
<li>直接在class中定义属性，这种属性是<strong>类属性</strong>，归类所有，类的所有实例都可以访问到，共享。</li>
</ul>
<figure class="highlight python"><figcaption><span>class-property</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    name = <span class="string">&#x27;Student&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</li>
</ul>
<h2 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h2><p>实例可以绑定属性和方法。</p>
<ul>
<li>绑定方法需要使用<code>types</code>模块的<code>Methodtype</code>方法。</li>
<li>对其他实例是不起作用的。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></li>
<li>为了给所有实例都绑定方法，可以给class绑定方法，所有实例均可调用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_score</span>(<span class="params">self, score</span>):</span></span><br><span class="line"><span class="meta">... </span>    self.score = score</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__slot__</code>可以限制实例的属性。<ul>
<li>仅对当前类实例起作用，对继承的子类是不起作用的。</li>
<li>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</li>
</ul>
</li>
</ul>
<h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><p>装饰器，实现比较复杂，把一个getter方法变成属性，创建另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值。<br><figure class="highlight python"><figcaption><span>@property</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._score  <span class="comment"># getter属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self, value</span>):</span> <span class="comment"># setter属性</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure></p>
<ul>
<li>@property使得对实例属性操作时，通过getter和setter方法来实现。</li>
<li>只定义getter方法就相当于定义了一个只读属性。</li>
</ul>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>一个子类就可以同时获得多个父类的所有功能。</p>
<ul>
<li>MixIn: 通过多重继承实现，除主线外的其他继承关系。</li>
<li>为了更好地看出继承关系，可以把主线外的继承类命名<code>xxxMixIn</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Mammal, RunnableMixIn, CarnivorousMixIn</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p>Python的class中有许多形如<code>__xxx__()</code>这样有特殊用途的函数，可以帮助我们定制类。</p>
<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><p><code>__str__</code>方法可以改变类的实例的打印方式，返回用户看到的字符串，<code>__repr__</code>返回程序开发者看到的字符串，用于调试。<br><figure class="highlight python"><figcaption><span>__str__</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;Student object (name: %s)&#x27;</span> % self.name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">&#x27;Michael&#x27;</span>))</span><br><span class="line">Student <span class="built_in">object</span> (name: Michael)</span><br><span class="line"><span class="comment"># 原来是&lt;__main__.Student object at 0x109afb190&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a>__iter__</h3><p>使得该对象可以被用于for循环。<br>该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。<br><figure class="highlight python"><figcaption><span>__iter__</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="number">46368</span></span><br><span class="line"><span class="number">75025</span></span><br></pre></td></tr></table></figure></p>
<h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a>__getitem__</h3><p>表现得像list那样按照下标取出元素。<br><figure class="highlight python"><figcaption><span>__getitem__</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isinstance</span>(n, <span class="built_in">int</span>)): <span class="comment"># n是索引</span></span><br><span class="line">            a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                a,b = b,a+b</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isinstance</span>(n, <span class="built_in">slice</span>)): <span class="comment"># n是切片</span></span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.start</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span>  <span class="literal">None</span>:</span><br><span class="line">                start = <span class="number">0</span></span><br><span class="line">            a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">            L = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(stop):</span><br><span class="line">                <span class="keyword">if</span> x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a,b = b,a+b</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">100</span>]</span><br><span class="line"><span class="number">573147844013817084101</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>以上<code>__getitem__()</code>方法没有对步长和负数做处理，因此要正确实现一个<code>__getitem__()</code>还是有很多工作要做的</li>
<li>如果把对象看成dict，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如str，与之对应的还有<code>__setitem__</code>和<code>__delitem__</code></li>
</ul>
<h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h3><p>动态返回一个属性，当调用不存在的属性时，会试图调用<code>__getattr__(self,属性)</code>来尝试获得属性。</p>
<ul>
<li>只有在没有找到属性的情况下才会调用<strong>getattr</strong>，已有的属性是直接获取的</li>
</ul>
<figure class="highlight python"><figcaption><span>__getattr__</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">    <span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;\&#x27;Student\&#x27; object has no attribute \&#x27;%s\&#x27;&#x27;</span> % attr)</span><br></pre></td></tr></table></figure>
<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h3><p>使实例自身能被当作函数调用。<br><figure class="highlight python"><figcaption><span>__call__</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;My name is %s.&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s()</span><br><span class="line">My name <span class="keyword">is</span> Michael</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通过<code>callable()</code>函数判断一个对象是否是“可调用”对象。</li>
</ul>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><figure class="highlight python"><figcaption><span>enum</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>这样我们就获得了Month类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    print(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>value</code>属性则是自动赋给成员的int常量，默认从1开始计数。</li>
</ul>
<p>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique </span><span class="comment"># @unique装饰器可以帮助我们检查保证没有重复值。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span>(<span class="params">Enum</span>):</span></span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">Weekday.Mon</span><br><span class="line">Weekday[<span class="string">&#x27;Tue&#x27;</span>]</span><br><span class="line">Weekday(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。</li>
</ul>
<h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><ul>
<li>动态语言的函数和类不是编译时定义的，而是运行时动态创建的。</li>
<li><code>type()</code>函数可以查看一个类型或变量的类型, 又可以创建出新的类型。</li>
<li>要创建一个class对象，<code>type()</code>依次传入3个参数<ul>
<li>class的名称</li>
<li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法</li>
<li>class的方法名称与函数绑定</li>
</ul>
</li>
</ul>
<figure class="highlight python"><figcaption><span>type()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">self, name=<span class="string">&#x27;world&#x27;</span></span>):</span> <span class="comment"># 先定义函数</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;Hello, %s.&#x27;</span> % name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello = <span class="built_in">type</span>(<span class="string">&#x27;Hello&#x27;</span>, (<span class="built_in">object</span>,), <span class="built_in">dict</span>(hello=fn)) <span class="comment"># 创建Hello class</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = Hello()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.hello()</span><br><span class="line">Hello, world.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">type</span>(Hello))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">type</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params"><span class="built_in">type</span>(<span class="params">h</span>)</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Hello</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass()"></a>metaclass()</h2><p>据说很复杂，等用到了再来看orz</p>
<h1 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h1><h2 id="try"><a href="#try" class="headerlink" title="try"></a>try</h2><ul>
<li>当我们认为某些代码可能会出错时，就可以用try来运行这段代码。</li>
<li>如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。</li>
<li>如果发生了不同类型的错误，可以有多个except来捕获不同类型的错误。</li>
<li>如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句。</li>
</ul>
<figure class="highlight python"><figcaption><span>try</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="built_in">int</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;result:&#x27;</span>, r)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;ValueError:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;ZeroDivisionError:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;no error!&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;END&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。</li>
<li>常见的错误类型和继承关系看<a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">这里</a></li>
<li>可以跨越多层调用, 不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了</li>
</ul>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</p>
<h2 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h2><p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息。</p>
<ul>
<li>程序打印完错误信息后会继续执行，并正常退出。</li>
<li>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</li>
</ul>
<h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><ul>
<li>根据需要，可以定义一个错误的类，选择好继承关系，用<code>raise</code>语句抛出一个错误的实例。</li>
<li>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型，尽量使用Python内置的错误类型。</li>
<li>当前函数不知道应该怎么处理该错误，继续往上抛，让顶层调用者去处理。</li>
<li>在<code>except</code>中<code>raise</code>一个Error，还可以把一种类型的错误转化成另一种类型</li>
</ul>
<figure class="highlight python"><figcaption><span>raise-err</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">s</span>):</span></span><br><span class="line">    n = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        foo(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&#x27;ValueError!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span>  <span class="comment"># 不带参数，就会把当前错误原样抛出</span></span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul>
<li><code>print</code>调试法</li>
<li><code>assert</code>调试法<ul>
<li><code>-O</code>可以关闭<code>assert</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><figcaption><span>assert</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> n != <span class="number">0</span>, <span class="string">&#x27;n is zero!&#x27;</span></span><br><span class="line">    <span class="comment">#表达式应该为True，否则输出AssertionError+后接的字符串</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>logging</code>调试法<ul>
<li>可以指定记录信息的级别，有<code>DEBUG</code> &gt; <code>INFO</code> &gt; <code>WARNING</code> &gt; <code>ERROR</code>等几个级别。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</li>
<li>另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><figcaption><span>logging</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line">logging.basicConfig(level=logging.INFO) <span class="comment"># 配置</span></span><br><span class="line">logging.info(<span class="string">&#x27;n = %d&#x27;</span> % n) <span class="comment"># 输出信息</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pdb调试法<ul>
<li>命令和gdb差不多</li>
<li><code>pdb.set_trace()</code>设置断点，在运行时程序会自动暂停并进入pdb</li>
</ul>
</li>
</ul>
<figure class="highlight python"><figcaption><span>pdb</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(s)</span><br><span class="line">pdb.set_trace() <span class="comment"># 运行到这里会自动暂停</span></span><br><span class="line">print(<span class="number">10</span> / n)</span><br></pre></td></tr></table></figure>
<ul>
<li>IDE调试法</li>
</ul>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li>对拍(?), difftest(?), 就是通过样例对设计进行正确性检验。</li>
<li>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</li>
<li><code>unittest</code>模块提供了方便测试的流程<ul>
<li>单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。</li>
<li>以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。</li>
<li>运行单元测试，<code>if __name__ == &#39;__main__&#39;:\unittest.main()</code> 或 <code>python -m unittest xxx.py</code>(推荐)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><figcaption><span>unittest</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mydict <span class="keyword">import</span> Dict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDict</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_init</span>(<span class="params">self</span>):</span></span><br><span class="line">        d = Dict(a=<span class="number">1</span>, b=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">        self.assertEqual(d.a, <span class="number">1</span>)  <span class="comment"># 断言函数返回的结果与1相等</span></span><br><span class="line">        self.assertEqual(d.b, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">        self.assertTrue(<span class="built_in">isinstance</span>(d, <span class="built_in">dict</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_key</span>(<span class="params">self</span>):</span></span><br><span class="line">        d = Dict()</span><br><span class="line">        d[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;value&#x27;</span></span><br><span class="line">        self.assertEqual(d.key, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_attr</span>(<span class="params">self</span>):</span></span><br><span class="line">        d = Dict()</span><br><span class="line">        d.key = <span class="string">&#x27;value&#x27;</span></span><br><span class="line">        self.assertTrue(<span class="string">&#x27;key&#x27;</span> <span class="keyword">in</span> d)</span><br><span class="line">        self.assertEqual(d[<span class="string">&#x27;key&#x27;</span>], <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_keyerror</span>(<span class="params">self</span>):</span></span><br><span class="line">        d = Dict()</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(KeyError): <span class="comment"># 期待抛出指定类型的Error</span></span><br><span class="line">            value = d[<span class="string">&#x27;empty&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_attrerror</span>(<span class="params">self</span>):</span></span><br><span class="line">        d = Dict()</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(AttributeError):</span><br><span class="line">            value = d.empty</span><br></pre></td></tr></table></figure>
<h2 id="文档测试-Doctest"><a href="#文档测试-Doctest" class="headerlink" title="文档测试 Doctest"></a>文档测试 Doctest</h2><ul>
<li>直接提取注释中的代码并执行测试。</li>
<li>严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用…表示中间一大段烦人的输出。</li>
<li>只有在命令行直接运行时，才执行doctest。</li>
</ul>
<h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。<br>同步IO, 异步IO</p>
<h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="comment"># 传入文件名和标示符, &#x27;r&#x27;表示读</span></span><br><span class="line"><span class="comment"># 文件不存在会抛出IOError错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close() <span class="comment"># 记得关</span></span><br></pre></td></tr></table></figure>
<p>为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><br>太繁琐, 和上面一样，会自动调用<code>f.close()</code>:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>read(size)</code>一次最多读取size个字节的内容</li>
<li><code>readline()</code>每次读取一行</li>
<li><code>readlines()</code>一次读取所有内容并按行返回list</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">    print(line.strip()) <span class="comment"># 把末尾的&#x27;\n&#x27;删掉</span></span><br></pre></td></tr></table></figure>
<p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。<br><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲</p>
<ul>
<li>默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b&#x27;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#x27;</span> <span class="comment"># 十六进制表示的字节</span></span><br></pre></td></tr></table></figure>
<ul>
<li>读取默认使用UTF-8编码，需要编码转换的时候要给open()传入encoding参数,errors参数表示出现错误后怎么处理，一般选择忽略</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><ul>
<li>调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件</li>
<li>用<code>with</code>语句保险</li>
<li>以’w’模式写入文件时，如果文件已存在，会直接覆盖。</li>
<li>传入’a’以追加（append）模式写入。</li>
</ul>
<h2 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h2><p>可以用一个str初始化StringIO，然后，像读文件一样读取<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO() <span class="comment"># 创建StringIO对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;world!&#x27;</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue()) <span class="comment">#getvalue()用于获得写入后的str</span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure></p>
<h2 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h2><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line"><span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>在操作系统中定义的环境变量，全部保存在os.environ这个变量中，可以直接查看<code>os.vnviron</code>, 是个dict<br>要获取某个环境变量的值，可以调用<code>os.environ.get(&#39;key&#39;)</code></p>
<ul>
<li>操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中</li>
<li>shutil模块有很多对os的补充<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前目录的绝对路径:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/Users/michael&#x27;</span></span><br><span class="line"><span class="comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;/Users/michael&#x27;</span>, <span class="string">&#x27;testdir&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/Users/michael/testdir&#x27;</span></span><br><span class="line"><span class="comment"># 然后创建一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)</span><br><span class="line"><span class="comment"># 删掉一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)</span><br><span class="line"></span><br><span class="line">os.path.join() <span class="comment"># 把两个路径合成一个</span></span><br><span class="line">os.path.split() <span class="comment"># 拆分路径</span></span><br><span class="line">os.path.splitext() <span class="comment"># 直接得到文件扩展名</span></span><br><span class="line"><span class="comment"># 这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对文件重命名:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;test.py&#x27;</span>)</span><br><span class="line"><span class="comment"># 删掉文件:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">&#x27;test.py&#x27;</span>)</span><br></pre></td></tr></table></figure>
一些应用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> os.path.isdir(x)] <span class="comment"># 列出当前目录下的所有目录</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> os.path.isfile(x) <span class="keyword">and</span> os.path.splitext(x)[<span class="number">1</span>]==<span class="string">&#x27;.py&#x27;</span>] <span class="comment"># 列出所有.py文件</span></span><br></pre></td></tr></table></figure>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2>pickle模块，用到再看。</li>
</ul>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
<h2 id="多进程-multiprocessing"><a href="#多进程-multiprocessing" class="headerlink" title="多进程(multiprocessing)"></a>多进程(multiprocessing)</h2><p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<ul>
<li>子进程永远返回0，而父进程返回子进程的ID。</li>
<li>Python的os模块封装了常见的系统调用，其中就包括fork.</li>
<li>multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块提供了一个Process类来代表一个进程对象。</li>
<li>如果要启动大量的子进程，可以用进程池(Pool)的方式批量创建子进程。</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>language</tag>
      </tags>
  </entry>
</search>
