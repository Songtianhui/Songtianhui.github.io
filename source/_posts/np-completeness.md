---
title: 问题求解笔记-NP完全性
date: 2021-05-10 20:21:03
categories: problem-solving
mathjax: true
tags:
typora-root-url: np-completeness
---

# 概述

- P类问题就是在多项式时间内可以被解决的（solvable）问题。

- NP类问题就是可以在多项式时间内可以被证明的（verifiable）问题。

  - verifiable：给定问题解的**证书（certificate）**，然后我们可以在多项式时间验证这个 certificate 是对的。

- 如果一个NP问题和其他任何NP问题一样“不易解决”，则是NPC问题。

  <!--more -->

## 规约 Reduction

有一个判定问题 A，一个判定问题 B，我们知道 $B$ 可以在多项式时间下解决，一个多项式时间规约算法（reduction algorithm）是将 A 的输入实例 $\alpha$ 转化成 B 的输入实例 $\beta$ 的过程，且：

- 转换操作需要多项式时间。
- 两个实例的解是相同的。

![](Screenshot from 2021-06-17 20-36-37.png)

*reduce方法的更深用意在于证明某个问题有多难。*

证明B有多难：假设A不是P问题，B不可能是P问题；反证法：如果B是P问题，那么A是P问题



---

# 多项式时间

**引理 34.1 ** 设 $Q$ 是定义在一个实例集 $I$ 上的抽象判定问题，$e_1$ 和 $e_2$ 是 $I$ 上多项式相关的编码，则 $e_1(Q) \in P \Leftrightarrow e_2(Q) \in P$。 

*今后不再讨论代价极高的编码，统一以二进制编码为基准。理论上，问题的难度是固有的。但是算法的复杂度，有时候却依赖于问题的编码。*



## 接受/判定

- 对任意输入 $x$，算法输出 $A(x) = 1$，就叫算法 $A$ **接受（accept）**$x \in \{0,1\}^{\star}$。被算法 $A$ 接受的语言就是集合 $L = \{x\in \{0,1\}^{\star} : A(x) = 1\}$。
- 对任意的输入 $x$，算法输出 $A(x) = 0$，就叫算法 $A$ **拒绝（reject）**$x \in \{0, 1\}^{\star}$。
- 算法 $A$ **判定（decide）**一个语言 $L$ 指对任意输入 $x$，在 $L$ 中的接受，不在 $L$ 中的拒绝。
- 区别在于 $A$ 接受 $L$ 只能确保在 $L$ 中的 $x$ 接受，不在 $L$ 中的也有可能接受，或没有结果（不终止）。

复杂类 $P$ 的定义：

$$P = \{L \subseteq \{0,1\}^{\star} : \text{存在一个算法 A，可以在多项式时间判定 }L\}$$

**定理 34.2 ** $$P = \{L \subseteq \{0,1\}^{\star} : \text{存在一个算法 A，可以在多项式时间接受 }L\}$$

*这个定理说明接受一个语言的多项式算法，一定可以被改造成判定一个语言的多项式算法。*

（A 最多 $cn^k$ 步接受输入，构造 A' 跑 $cn^k$ 步，接受返回 1，否则返回 0，判定了 $L$。）



# 多项式时间的验证 Verification

一份**验证算法（verifier）** 是一个两个变量的算法 A，一个输入为串 $x$，另一个是叫**证书（certificate）**的二进制串 $y$。如果存在一个证书 $y$ 使得 $A(x, y) = 1$，则称 $A$ **验证（verify）**了输入 $x$。

一个由算法 A 验证的语言是 $$L = \{x \in \{0, 1\}^{\star} : \exists y \in \{0,1\}^{\star} , A(x, y) = 1\}$$。

复杂类 NP 定义：一个语言 $L$ 属于 NP 当且仅当存在一个两输入多项式时间算法 $A$ 和常数 $c$，使得

$$L = \{x \in \{0, 1\}^{\star} : \text{存在一个证书 }y, |y| = O(|x|^c), A(x,y) = 1 \}$$。

*当证书是超多项式的时候，验算证书的代价不再是保证为多项式了。*



P问题是可以在多项式时间内被判定的问题。

NP问题是所有可以在多项式时间内被验证的问题。

co-NP是所有它的补是NP问题的问题。

**大多数人相信 $P \neq NP$。**



---

# NP完全性与可规约性

引入NPC：只要有一个NPC可以多项式求解，那么所有的NP问题都可多项式求解。



## 可规约性 Reducibility

- 如果存在一个多项式时间可计算函数 $f : \{0, 1\}^{\star} \to \{0, 1\}^{\star}$，满足 $\forall x \in \{0 , 1\}^{\star}, x \in L_1 \leftrightarrow f(x) \in L_2$，则称语言 $L_1$ 可以在多项式时间内规约到语言 $L_2$，记作 $L_1 \leq_p L_2$。
  - $f$ 叫规约函数
  - 算 $f$ 的算法叫规约算法

**引理 34.3 ** 如果 $L_1, L_2 \subseteq \{0 ,1\}^{\star}$ 是满足 $L_1 \leq_p L_2$ 的语言，则 $L_2 \in P \Rightarrow L_1 \in P$。

*隐藏着：L1的复杂度不会“f多项式以上”超过L2的复杂度。*

*更深层次的隐藏着：如果L1很难，L2不能很简单：最多相差多项式因子。*

*揭示了认知一个问题的难度的方法学：如果一个老问题能够归约到待认知的新问题，这个新问题的难度最多简单到多项式因子*



## NP完全性

语言 $L$ 是 NP完全的，如果：

1. $L \in NP$
2. $\forall L' \in NP, L' \leq_p L$

- 如果 $L$ 只满足性质2，但不一定满足性质1，叫 **NP难（NP-hard）**的。



**定理 34.4 ** 如果任何 NP完全问题是多项式时间可解的，则 $P = NP$。等价的，如果存在某一个NP问题不是多项式可解的，则所有NP完全问题都不是多项式时间可解的。

**定理 34.7 ** 电路可满足性问题是NP完全的。
